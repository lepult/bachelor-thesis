% TODO textcommand für Scenegraph-Ebene, SimpleMesh-Ebene, Icon-Ebene

\newpage
\section{Umsetzung}
Im Folgenden wird die Implementierung, sowie die Evaluierung des Prototyps beschrieben. Bei der Skizzierung der Mockups und auch später während der Implementierung wurde darauf geachtet eine gute Benutzerfreundlichkeit zu bieten. Hierfür wurde sich an den 1994 von Nielsen entwickelten 10 Usability Entscheidungsregeln \cite{Nielsen.1994} orientiert. Im kommenden Kapitel \ref{sec:UsabilityHeuristics} wird genauer geprüft wie gut diese eingehalten wurden.

\subsection{Mockup}
Für den Prototyp wurden Mockups skizziert an denen sich während der Implementierung orientiert werden konnte. Diese Mockups wurden zunächst auf Papier niedergeschrieben und für die folgende Beschreibung mithilfe von Figma \cite{Figma} digitalisiert. Es gibt jeweils ein Mockup für die Übersicht, Steuerung und Verwaltung, sowie für das Routenplanungs-Popup.

Abbildung \ref{fig:MockupOverview} zeigt das Mockup für die Übersicht. In der Übersicht werden die Raummodelle zusammen mit den verschiedenen Roboterdaten angezeigt. So werden die Standorte mithilfe von Icons, die Roboterpfade mithilfe von Linien und die Roboterpositionen mithilfe von 3D-Modellen der Roboter dargestellt. Es gibt außerdem Buttons mit denen zwischen den verschiedenen Stockwerken navigiert werden kann. Auch gibt es Buttons, mit denen die Roboter ausgewählt werden können. Zusätzlich gibt es einen Button, der es ermöglicht den ausgewählten Roboter automatisch zu verfolgen und einen anderen Button mit dem die Kameraposition wieder auf die Ausgangsposition zurückgesetzt werden kann. Die Buttons sind abhängig von ihren Funktionen in den vier Ecken der Anwendung gruppiert.

Die Steuerung in Abbildung \ref{fig:MockupControls} erweitert die Übersicht um weitere Funktionen und sieht daher fast identisch aus. Der einzige Unterschied sind zusätzliche Buttons mit denen eine Lieferroute bestimmt, der Roboter zum Aufladen zur Ladestation geschickt, oder der aktuelle Lieferauftrag abgebrochen werden kann. Die Abbildung \ref{} zeigt das Mockup für das Routenplanungs-Popup das sich öffnet, wenn der Lieferroute-Button ausgewählt wird. In diesem muss ein Ziel und ein Roboter ausgewählt werden.
% TODO Add Mockup for RoutePlanning
% TODO zusätzliche Funktionen erwähnen? => Auch können optional ein Ausgabepunkt und Zwischenstationen eingestellt werden.
Um die Routenerstellung zu vereinfachen, sollen sowohl Roboter als auch Standorte über das Anklicken auf der Karte auswählbar sein.

Die Abbildung \ref{fig:MockupAdministration} zeigt das Mockup für die Verwaltung. Hier gibt es jeweils eine Liste für die Roboter und die Stockwerke. In der Liste der Roboter können verschiedene Informationen der einzelnen Roboter, wie beispielsweise der systeminterne \ac{ID} und die Neustartzeit ausgelesen werden. Auch können Einstellungen der Roboter, wie Name und Ausgabepunkt geändert werden. Zudem gibt es für jeden Roboter eine Vorschau der Übersicht, in der die Position des Roboters gezeigt wird. In der Liste der Stockwerke gibt es für jedes Stockwerk eine Übersicht über die jeweiligen Standorte eines Stockwerks. Wie in der Roboterliste gibt es auch hier eine Vorschau der Übersicht für das jeweilige Stockwerk. Zusätzlich gibt es ein Kontextmenü, über das in den Editiermodus des Stockwerks gewechselt werden kann. In diesem sollen die Roboterdaten und Stockwerke manuell synchronisiert werden können. Ein Mockup wurde hierfür nicht entwickelt, da das Aussehen zu stark von den Möglichkeiten in \deckgl{} abhängt, die zum Zeitpunkt der Entwicklung des Mockups noch nicht vollständig bekannt waren und erst während der Implementierung bekannt wurden. Somit wurde bestimmt, dass das Aussehen des Editiermodus während der Implementierung festgelegt werden muss.

\subsection{Implementierung}
Es wurde ein Frontend entwickelt, dass auf das \ac{BCB} zugreift, um die Roboterdaten anzufragen. Wie das \ac{BCB} hierbei mit den Robotern kommuniziert, wird im Kapitel \ref{sec:BotControlBackend} erklärt. Das Frontend nutzt das Web-Framework React in Kombination mit \ac{HTML}, \ac{SCSS} und Typescript. Die Vorteile von Typescript und \ac{SCSS} gegenüber Javascript und \ac{CSS} wird im Kapitel \ref{sec:WebTechnologies} erläutert. Auch React wird dort erklärt. 
% Typscript wurde aufgrund der statischen Typisierung, frühzeitigen Fehlererkennung und besseren Wartbarkeit gegenüber Javascript. Da SCSS eine bessere Übersichtlichkeit der Stylesheets ermöglicht, wurde es statt CSS eingesetzt.
Zustandsinformationen die Komponentenübergreifend abgerufen werden, werden zentral mithilfe von React-Redux gespeichert. Die Grundstruktur des Frontend-Projekts wurde mihilfe des Shell Befehls "npx create-chayns-app" \cite{CreateChaynsApp} generiert. Die Kompilierung ist mithile des \ac{npm}-Pakets "chayns-toolkit" \cite{ChaynsToolkit} konfiguriert. \ac{GUI}-Elemente wie Buttons und Aufklapper werden durch die Komponentenbibliothek "chayns-components" \cite{ChaynsComponents} bereitgestellt. Außerdem werden die \ac{npm}-Pakete clsx \cite{clsx} und fortawesome \cite{fontawesome} eingesetzt. Mithilfe von clsx lassen sich HTML Klassennamen Kompackt unter Bedingungen anwenden. Das fortawesome \ac{npm}-Paket wird genutzt, um \ac{SVG} Icons als Zeichenkette zu importieren. Ein großer Teil der Typescript Type-Definitionen konnte aus einem anderen Frontend-Projekt kopiert werden. Hierbei handelt es sich um Types für Objekte, die aus dem \ac{BCB} stammen.

\subsubsection{Übersicht}
In der Übersicht werden die Roboterdaten in Kombination mit den Gebäudemodellen mithilfe von \deckgl{} angezeigt. Hierfür werden verschiedene \deckgl{}-Layers eingesetzt.

\paragraph{Gebäudemodelle}
Für den Prototyp sind die \ac{URL}-Verweise der 3D-Modelle hartkodiert, also in den Quelltext der Webanwendung eingebettet. Für ein potenzielles Produktivsystem müssten die \ac{URL}-Verweise in der Datenbank des \ac{BCB}s abgespeichert werden. Die Modelle sind im chanys.space gespeichert und werden aus Gründen, die in Kapitel \ref{sec:ModelFileFormat} bereits erläutert wurden, im \ac{glTF}-Format geladen und in der ScenegraphLayer angezeigt. Diese Ebene ist dafür ausgelegt, ein bestimmtes 3D-Modell beliebig oft an verschiedenen Positionen anzuzeigen \cite{DeckglScenegraphLayer}, was auf die Hauptfunktion von \deckgl{} - die Visualisierung riesiger Geodaten Mengen \cite{Deckgl} - zurückzuführen ist. Aus diesem Grund muss für jedes 3D-Modell eine eigene Instanz der ScenegraphLayer erzeugt werden. \deckgl{} ist für den Einsatz von über 100 Ebenen gleichzeitig ausgelegt, wobei wahrscheinlich sogar der einsatz von bis zu 1000 Ebenen ohne große Performance Einbußen möglich ist \cite{DeckglPerformance}. Im Prototyp besteht ein Stockwerk aus bis zu sechs 3D-Modellen und somit auch aus sechs ScenegraphLayers. Da nicht davon auszugehen ist, dass jemals mehr als 15-mal so viele Modelle für ein Stockwerk nötig sind, sind keine negativen Performance-Auswirkungen durch den Einsatz einer Ebene für ein einzelnes Modell zu erwarten.
% TODO Zahl anpassen, falls mehr Modelle genutzt werden
Für die Scenegraph-Layers ist das Backface Culling aktiviert. Mithilfe vom Backface Culling werden die von der Kamera weggerichteten Polygone ausgeblendet \cite{BackfaceCulling}. Meist wird Backface Culling genutzt, um Polygone auszublenden, die sowieso hinter anderen Polygonen versteckt sind, um die Darstellungsgeschwindigkeit zu erhöhen. Im Fall der Gebäudemodelle sind die Polygone in den Raum hineingerichtet. Somit bewirkt das Backface Culling, dass die Wände und Decken ausgeblendet werden, die dem Nutzer die Sicht in den Raum verdecken würden. In der Abbildung \ref{fig:BackfaceCulling} wird dieser Effekt verdeutlicht. So sieht man auf der linken Seite, dass ohne das Backface Culling nicht in den Raum hineingesehen werden kann, während es auf der rechten Seite mit Backface Culling möglich ist.

\begin{figure}[H]
    \caption{Raummodell ohne und mit Backface Culling}\label{fig:BackfaceCulling}
    \includegraphics[width=0.9\textwidth]{Backface Culling Vergleich.png}
    \\
    Quelle: Eigene Darstellung
\end{figure}
% TODO Ist "Quelle: Eigene Darstellung" richtig?
% TODO Erwähnen falls 3D-Modelle gecached werden

\paragraph{Roboterdaten}\label{sec:RobotData}
Die Roboterdaten werden über verschiedene Endpunkte des \ac{BCB}s abgerufen. So gibt es einen Endpunkt für die Bezeichnungen der verschiedenen Standorte und einen Endpunkt für den Roboterstatus, Lieferautrag und die Roboterposition \cite{BCBSwagger}. Für die Positionen aller Standorte und der Roboterpfade gibt es keinen Endpunkt. Stattdessen können die Standorte und Pfade nur von Stockwerken angefragt werden, in denen sich Roboter zu dem Zeitpunkt befinden, da diese Daten direkt von den Robotern angefragt werden. Damit immer alle Daten aus allen Stockwerken abgerufen werden können, sind diese Daten im Prototyp für alle Stockwerke hartkodiert. Für ein potenzielles Produktivsystem müssten diese Daten in der Datenbank des \ac{BCB}s gespeichert und regelmäßig mit den Robotern synchronisiert werden.
% Braucht es ein Schaubild in dem die erweiterte Datenbankstrukur dargestellt wird?

Im Gegensatz zu den Gebäuademodellen werden die Robotermodelle im \ac{OBJ}-Format mit der SimpleMeshLayer \cite{DeckglSimpleMeshLayer} angezeigt. Mit der ScenegraphLayer gibt es das Problem, dass die Positionen der Modelle nicht animiert werden können, wodurch die SimpleMeshLayer brauchbarer, aber auch nicht ideal, ist. Laut der Dokumentation voj \deckgl{} sollte das Animieren über die transition Property in allen Ebenen möglich sein \cite{DeckglLayerClass}. Deshalb handelt es sich bei dem Problem mit der ScenegraphLayer vermutlich um einen Bug in \deckgl{}. Wie im Kapitel \ref{sec:ModelFileFormat} erwähnt, lässt sich die Materialdatei des \ac{OBJ} Formats nicht in der SimpleMeshLayer einbinden, weshalb die Roboter einfarbig angezeigt werden müssen. Das ist nicht unbedingt ein Nachteil, denn so können die Roboter mithilfe einer herausstechenden Farbe für den Nutzer besser sichtbar gemacht werden. Die Positionsänderungen der Roboter werden über die transitions Property animiert. Allerdings lässt sich die Rotation nicht animieren, was vermutlich auch auf einen Bug in \deckgl{} zurückzuführen ist.

Über den Robotermodellen wird mithilfe der IconLayer der aktuelle Status der Roboter angezeigt. Während in einer ScenehraphLayer-Instanz nur ein bestimmtes 3D-Modell angezeigt werden kann, können in einer IconLayer-Instanz verschiedene Bilder mithilfe der getIcon Zugriffsfunktion angezeigt werden \cite{DeckglIconLayer}, weshalb hierfür im Gegensatz zur ScenegraphLayer eine Layer-Instanz ausreicht. Die genutzten Icons stammen aus der Icon-Bibliothek Fontawesome und werden aus dem fortawesome \ac{npm}-Paket als \ac{SVG}-Zeichenkette importiert. Da die IconLayer das \ac{SVG} Format nicht unterstützt, werden die \ac{SVG}-Zeichenketten in das Data-\ac{URL} Format umgewandelt. Das Data-\ac{URL} Format bettet Daten als \gls{Base64}-Zeichenkette innerhalb einer \ac{URL} ein \cite{DataUrl}.

Die verschiedenen Standorte werden über die IconLayer angezeigt. Wie bei den Roboter-Zuständen werden hierfür verschiedene Fontawesome-Icons genutzt. Wurde ein Roboter ausgewählt und hat dieser einen Lieferauftrag, dann wird der Zielstandort farbig markiert. Die Pfade und virtuellen Wände werden über eine Instanz der PathLayer \cite{DeckglPathLayer} dargestellt. Die virtuellen Wände werden gestrichelt und in einer anderen Farbe angezeigt, um diese von den Roboterpfaden zu unterscheiden. Für die gestrichelte Darstellung wird die PathStyleExtension \cite{DeckglPathStyleExtension} genutzt.

Bei der folgenden Abbildung handelt es sich um einen Screenshot des Prototyps. Man sieht alle erwähnten Ebenen. So sieht man ein Gebäudemodell, ein Roboter mit einem Icon, das den Status repräsentiert, verschiedene Pfade und verschiedene Standorte.
% TODO Screenshot hinzufügen

\paragraph{Echtzeit-Aktualisierung}
Die Positionen sowie weitere Statusinformationen der Roboter, wie beispielsweise der aktuelle Auftrag und Akkuladung, werden mithilfe einer indirekten \gls{Websocket}-Verbindung zwischen der Webanwendung und dem \ac{BCB} regelmäßig aktualisiert. Hierfür wird der im Kapitel \ref{sec:Chayns} beschriebene \gls{Websocket}-Service genutzt. In der folgenden Abbildung ist der Ablauf einer Statusaktualisierung vereinfacht dargestellt. Aktualisiert ein Roboter seine Position, wird die entsprechende Information über \gls{MQTT} an das \ac{BCB} gesendet.
% Passt das so? Funktioniert MQTT wie beschrieben?
Das \ac{BCB} sendet daraufhin eine Nachricht an den \gls{Websocket}-Service, der diese Information wiederum an alle verbundenen Clients schickt.
% TODO Schaubild einfügen.

Die über den \gls{Websocket}-Service empfangene Statusaktualisierung wird zentral im Redux-Store aktualisiert, sodass dem Nutzer die Aktualisierung direkt angezeigt werden kann. Bei Positonsänderungen der Roboter werden diese mithilfe des transitions Attributs der SimpleMeshLayer und der IconLayer animiert \cite{DeckglLayerClass}. So entsteht der Eindruck, dass die Roboter fahren. Wie im Kapitel \ref{sec:RobotData} erwähnt, lässt sich für die Robotermodelle allerdings nur die Position und nicht die Rotation animieren.

\paragraph{Interaktion}
Die Roboter, sowie die Standorte sind, mithilfe der onClick Property der entsprechenden Ebene \cite{DeckglInteractivity}, auswählbar. Ausgewählte Standorte und Roboter werden verfärbt angezeigt. Außerdem erscheint ein Button über den sich weitere Informationen wie beispielsweise die Akkuladung bei Robotern und der Name bei Standorten anzeigen lässt. Schwebt die Maus über einem Standort oder Roboter, dann wird mithilfe der getTooltip Property \cite{DeckglDeckClass} ein Tooltip angezeigt, in dem der Name des entsprechenen Objekts steht. Es gibt zudem die Möglichkeit einem Roboter zu Folgen. Die Kamera wird hierfür mithilfe des FlyToInterpolators \cite{DeckglFlyToInterpolator} zu dem ausgewählten Roboter bewegt. Während einem Roboter gefolgt wird, wird die Kameraposition mithilfe der transitionDuration Property \cite{DeckglAnimationsAndTransitions} animiert, wenn die Roboterposition aktualisiert wird.

\subsubsection{Steuerung}
Es gibt drei verschiedene Aktionen zum Steuern der Roboter: Lieferauftrag, Laden und Abbrechen. Mit dem Laden und Abbrechen wird der aktuelle Lieferauftrag abgebrochen, worauf der Nutzer auch hingewiesen wird. Für beide Aktionen gibt es jeweils einen Button, der klickbar ist, sobald ein Roboter ausgewählt wurde. Während der Roboter durch das Laden zur Ladestation fährt, bewegt sich der Roboter durch Abbrechen nicht mehr. Für das Einstellen eines Lieferauftrags muss ein Ziel und ein Roboter, sowie optional ein Ausgabepunkt und Zwischenstationen ausgewählt werden. Hierfür gibt es zum einen Inputs, mit denen nach Standorten und Robotern gesucht werden kann. Bei den Inputs handelt es sich um die PersonFinder-Komponente \cite{ChaynsPersonFinder} der chayns-components, die eigentlich für das Suchen nach chayns Nutzern genutzt wird. Im Prototyp ist die Komponente für das Suchen nach Standorten entsprechend konfiguriert.

Auch lassen sich Standorte und Roboter mit der Auswahl über die Karte festlegen. Die Roboter können zudem über ihre Buttons ausgewählt werden. Bei der Auswahl der entsprechenden Standorte sind ungültige Standorte auf der Karte ausgegraut und nicht auswählbar. So können Türen oder Fahrstühle weder als Ausgabepunkt noch als Zielpunkt angegeben werden. Als Ausgabepunkt kann währenddessen beispielsweise kein Zielpunkt ausgewählt werden. Zum entgültigen Ausführen der drei Aktionen werden die entsprechenden Endpunkte im \ac{BCB} \cite{BCBSwagger} aufgerufen.

\subsubsection{Verwaltungsansicht}
Die Verwaltungsansicht ist nicht besonder komplex, da die Daten der Roboter und Stockwerke sauber strukturiert sind und somit leicht mithilfe von React gemappt werden können.

In der Roboterliste werden im Gegensatz zum Mockup mehr Statusinformationen der Roboter angezeigt. Auch können mehr Einstellungen der Roboter geändert werden. Da die Übersicht über die verschiedenen Standorte auch über die Liste der Stockwerke ersichtlich ist und dadurch redundant ist, ist diese nicht in der Roboterliste vorhanden. Stattdessen gibt es einen Button, über den man vom Roboter zum entsprechenden Stockwerk in der Stockwerk-Liste navigieren kann. Die Stockwerkliste unterscheidet sich nur geringfügig vom Mockup. So werden die Standorte im Gegensatz zum Mockup gruppiert nach der Art des Standorts aufgelistet. Der Grund hierfür ist, dass die Art des Standortes nicht aus dem Namen ersichtlich sein muss. Entsprechend gibt es eine bessere Übersichtlichkeit über die verschiedenen Standorte als im Mockup.

In beiden Listen gibt es eine Vorschau des entsprechenden Stockwerks, um die Position des Roboters oder der Standorte zu zeigen. Hierbei handelt es sich um die Nutzeransicht mit weniger Funktionalitäten. Die Vorschau ist im Mockup automatisch geöffnet, was ein Problem ist, da die entsprechende \deckgl{}-Karteninstanz - aufgrund des Verhaltens der genutzten Aufklapper-Komponente - beim Öffnen des Aufklappers initialisiert wird. Die Initialisierung der \deckgl{}-Karteninstanz ist rechnerisch aufwändig und verursacht dadurch beim ersten Öffnen des Aufklappers starke Ruckler. Um dieses Verhalten zu verbessern wird stattdessen ein Button angezeigt, über den die Karte manuell initialisiert werden kann. Dadurch gibt es die Ruckler erst beim Klicken des Buttons und nicht beim Öffnen des Aufklappers, was weniger störend ist.

Bei jedem Stockwerk gibt es die Möglichkeit in den Editiermodus zu navigieren.

\subsubsection{Editiermodus}
Wie bereits erwähnt müssen die Roboterdaten mit den 3D-Modellen manuell synchronisiert werden. Hierfür gibt es einen Editiermodus. In diesem wird die Nutzeransicht mit Editiermöglichkeiten angezeigt. Da der Einsatz der Steuerungs- und Umschalttaste nötig ist, kann dieser Modus nicht an Mobilgeräten genutzt werden. Im Editiermodus hat der Nutzer die Möglichkeit neue 3D-Modelle zu importieren. Hierfür gibt es einen einfachen Dateiinput der nur Dateien im \glb{} Format erlaubt. Wie bereits erwähnt sind die 3D-Modelle im Prototyp hartkodiert. Entsprechend werden Änderungen sowie neu importierte 3D-Modelle nur für die aktuelle Sitzung gespeichert und gehen verloren, wenn die Anwendung und somit eine neue Sitzung erneut geöffnet wird. Mithilfe der in \deckgl{} integrierten Events onDragStart, onDrag und onDragEnd \cite{DeckglInteractivity} kann das angeklickte 3D-Modell per Ziehen der Maus verschoben und rotiert werden. So wird das ausgewählte Modell beim Ziehen entweder verschoben oder rotiert, je nachdem ob die Steuerungs- oder Umschalttaste gedrückt wurden. Das Verschieben und Rotieren kann mithilfe der Tastenkombination Strg + Z rückgängig gemacht und mit Strg + Y wiederholt werden. Hierfür wurden zwei Stapel implementiert in denen die vergangenen und rückgängiggemachten Aktionen gespeichert werden.

Der Boden der 3D-Modelle liegt relativ konstant auf der z-Koordinate 0. Auf der z-Achse wird die vertikale Position gespeichert. Aufgrund der Ungenauigkeiten die durch den \ac{LiDAR}-Scan entstehen ist der Boden aber nicht vollständig eben. Da die Roboterdaten zweidimensional und somit keinen Höhenwert haben besteht die Gefahr, dass diese an manchen Stellen unter dem Boden der 3D-Modelle verschwinden, wenn sie auf der Höhe 0 angezeigt werden. Aus diesem Grund werden die Roboterdaten an einer erhöhten z-Koordinate positioniert. Da der Boden bei allen 3D-Modellen an derselben z-Koordinate positioniert ist, müssen diese durch den Nutzer nicht weiter an der z-Achse verschoben werden. Im Vergleich zu den Roboterdaten sind die 3D-Modelle immer um 90° an der z-Achse und einen beliebigen Wert an der y-Achse rotiert. Die Rotation der x-Achse stimmt zwischen 3D-Modellen und Roboterdaten bereits überein. Die 3D-Modelle werden automatisch um -90° an der z-Achse rotiert und müssen vom Nutzer somit nur nach an der y-Achse rotiert werden. Falls die 3D-Modelle auch aus anderen Quellen kommen sollen, dann bräuchte der Nutzer auch die Möglichkeit diese um die z-Achse zu rotieren, da dann nicht mehr garantiert werden kann, dass die Rotation übereinstimmt. Da sich die Roboterdaten und 3D-Modelle denselben Maßstab teilen braucht der Nutzer nicht die Möglichkeit diese zu skalieren. Durch den Einsatz von 3D-Modellen aus anderen Quellen, wäre diese Möglichkeit aber möglicherweise nötig.
% TODO Schaubild in dem Datenbankstruktur um die entsprechende Tabelle erweitert wird (3D-Modelle und Positionen)

\subsection{Deployment}

Für das Veröffentlichen des Prototyps wird GitHub Actions genutzt in Kombination mit GitHub Pages genutzt. Mit GitHub Actions lassen sich die Build-, Test- und Bereitstellungspipeline eines Projekts automatisieren \cite{GitHubActions}. So wird bei der Aktualisierung des main Branches automatisch ein Build erstellt und mithilfe der actions-gh-pages Github Action auf GitHub Pages bereitgestellt. Die Webanwendung wird mithilfe der actions-gh-pages GitHub Action auf GitHub Pages veröffentlicht. Bei GitHub Pages handelt es sich um einen Hosting-Dienst für statische Websites, der mit den nötigen Daten aus GitHub Repositories Websites veröffentlichen kann \cite{GitHubPages}.

Die Anwendung verwendet verschiedene Funktionen der chayns-api \cite{ChaynsApi}, wie beispielsweise das Anfordern eines Zugangstokens, ohne den bestimmte Funktionen des Backends nicht aufgerufen werden können.
Aus diesem Grund funktioniert die Anwendung nur, wenn sie - wie in der Dokumentation des create-chayns-app Befehls \cite{CreateChaynsApp} - als Custom Page auf einer chayns Seite eingebunden ist. Der Zugriff auf die meisten Funktionen des \ac{BCB}s ist so eingeschränkt, dass diese nur auf bestimmten chayns Seiten aufgerufen werden können. Nur bestimmte GET-Endpunkte des \ac{BCB}s sind unabhängig von der chayns Seite aufrufbar, sodass die Steuerungs- und Verwaltungsfunktionen nicht ohne die nötigen Berechtigungen genutzt werden können.

\subsection{Evaluierung des Prototyps}
Im Folgenden wird gezeigt welche funktionalen Anforderungen und inwieweit die nicht funktionalen Anforderunge der Usability und Performance erfüllt wurden.

\subsubsection{Funktionale Anforderungen}
Im Kapitel \ref{sec:FunctionalRequirements} sind die funktionalen Anforderungen erläutert, wovon die meisten erfüllt sind, weshalb hier nur die nicht erfüllten Anforderungen erwähnt werden. Bei dem Protyp handelt es sich zwar - wie in den Anforderungen definiert - um eine responsive Webanwendung, sie funktioniert allerdings nicht auf allen Geräten vollständig. So können die für die Gebäudemodelle genutzten \ac{glTF}-Modelle nicht im Safari Browser angezeigt werden, vermutlich weil diese das \ac{WebP} Bildformat nutzen und dieses noch nicht vollständig von Safari unterstützt wird \cite{CanIUseWebP}. Da es sich hierbei um eine Beschränkung des Safari-Browsers und nicht der Anwendung selbst handelt, die in Zukunft von Apple behoben werden sollte und weil alle anderen Funktionen des Prototyps auch im Safari-Browser funktionieren, wurde hierfür kein Workaround entwickelt. Während die Positionsänderungen der Roboter animiert werden, ist das bei den Rotationsänderungen aufgrund eines Bugs in \deckgl{} nicht der Fall. Aus diesem Grund ist die Anforderung, dass der Roboter in der Übersicht fährt nur teilweise erfüllt. Alle anderen funktionalen Anforderungen wie die an die Nutzerrechte und Verwaltungsansicht konnten erfüllt werden.

Die Anforderungen an die Methode zur Gebäudemodell-Generierung konnten weitestgehend erfüllt werden. Für die Methode wird zwar ein iPhone benötigt, dieses besitzt man als Nutzer aber unter umständen bereits. Das Generieren der Modelle erfordert vergleichsweise wenig Aufwand, wobei dieser davon abhängig ist, wie genau das Scannen durchgeführt wird. Für das Scannen ist nur wenig Know-How nötig. Die Modelle müssen zwar komprimiert werden, wofür beispielsweise das im Kapitel \ref{sec:ModelFileFormat} erwähnte Webtool infrage kommt. Hierfür könnte aber auch mithilfe des \ac{glTF}-Transform Pakets \cite{glTF-Transform} automatisch beim Import eines 3D-Modells in den Editiermodus komprimiert werden. Die Qualität der erzeugten Modelle variiert zum einen dadurch wie gut der Scann durchgeführt wurde und welche Methode zur Komprimierung des Modells genutzt wird. Vergleichsweise geringe Ungenaugkeiten im Modell haben keinen Einfluss auf die Übersichtlichkeit und damit die Hauptfunktion des Modells. 

\subsubsection{Benutzerfreundlichkeit}
Die Benutzerfreundlichkeit wird sowohl anhand der Erfüllung der Usability Entscheidungsregeln als auch durch die Auswertung von Usability-Tests beurteilt.

\paragraph{Usability Heuristics}\label{sec:UsabilityHeuristics}
Die Usability Entscheidungsregeln konnten weitestgehend eingehalten werden. Im Folgenden wird aufgezeigt wie einige der Entscheidungsregeln konkret eingehalten werden.

Bei der ersten Regel geht es darum, dass der Nutzer immer innerhalb einer angemssenen Zeispanne durch geeignete Rückmeldungen mitbekommt, was gerade passiert. Diese Regel ist durch verschiedene Features in der Übersicht und Steuerung erfüllt. Zum einen gibt es die Echtzeit-Aktualisierungen des Roboterstandorts und -status über die \gls{Websocket}-Verbindung mit dem \ac{BCB}. Zum anderen werden Statusänderungen auch über die Farben der Buttons signalisiert. Auch gibt es Wait Cursor, um Ladevorgänge anzuzeigen. In der Verwaltung werden Einstellungsänderungen außerdem direkt angezeigt.

% Die zweite Regel erwartet, dass der Nutzer die Sprache der Anwendung versteht und somit beispielsweise möglichst wenig Fachsprache verwendet wird. In der Steuerung und Verwaltung gibt es nur wenig Text, da vor allem Icons eigesetzt werden. In der Verwaltungsansicht werden möglicherweise unklare Begriffe wie Ladestation über Tooltips erklärt. Außerdem werden Einstellungsänderungen über Dialoge erklärt.

Da Benutzer oft versehentlich Aktionen ausführen, gibt es die dritte Regel, mit der klar gekennzeichnete Abbruchoptionen gefordert werden, um unerwünschte Aktionen abbrechen oder rückgängig machen zu können. Um die Kamera wieder in die Ausgangsposition zu bringen, wenn diese versehentlich an eine ungewünschte Position bewegt wurde, gibt es in der Übersicht einen entsprechenden Button. In der Steuerung gibt es außerdem einen Button mit dem der aktuelle Lieferauftrag des Roboters abgebrochen werden kann. Auch gibt es sowohl in der Steuerung als auch in der Verwaltung Bestätigungsdialoge mit denen neue Aktionen und Einstellungsänderungen bestätigt werden müssen, wodurch eine ausgewählte Aktion noch abgebrochen werden kann. Im Editiermodus gibt es die Möglichkeit das Verschieben und Rotieren von Objekten rückgängig zu machen oder zu wiederholen. Auch gibt es im Editiermodus einen Button mit dem das editieren ohne Speichern abgebrochen werden kann.

% Die vierte Regel sagt aus, dass die UI den Konventionen der Plattform folgen soll und die UI innerhalb der gesamten Anwendung einheitlich ist, damit die Funktion aller Elemente leicht verständlich ist. Diese Regel wird durch den Einsatz der chayns-components für alle GUI Elemente garantiert. So ist die Anwendung sowohl innerlich, als auch unter chayns-Anwendungen einheitlich. 
% TODO ggf. Schaubild in dem Einheitlichkeit zwischen Nutzerkarte und Editiermodus gezeigt wird.
% Die Navigation innerhalb der Karte ist nicht einheitlich mit anderen Kartenanwendungen im Web. So lässt sich die Karte in der Google Maps App mit zwei Fingern vertikal rotieren. Im Prototyp werden stattdessen drei Finger gebraucht. Dieser Umstand ist dem eingesetzten Framework \deckgl{} geschuldet \cite{DeckglController}.

In der fünften Regel geht es darum, dass Probleme die Fehler auslösen verhindert werden sollten. In der Steuerung ist es zum Beispiel nicht möglich ungültige Standorte in der Routenplanung einzugeben. Währenddessen wird diese Regel in der Verwaltung durch die bereits erwähnten Bestätigungsdialoge erfüllt. Im Editiermodus gibt es die bereits erwähnte Rückgängigmachen und Wiederhohlen Funktion.

% Mit der sechsten Regel wird gefordert, dass sich der Nutzer Informationen zwischen verschiedenen Teilen der Benutzeroberfläche nicht merken muss. Die Anwendung ist so aufgeteilt, dass jeder Nutzer basierend auf seinen Berechtigungen Zugriff auf alle nötigen Informationen hat. In allen Ansichten sind die nötigen Informationen sichtbar, sodass sich Nutzer diese nicht zwischen verschiedenen Ansichten merken müssen.

In der siebten Regel geht es um die Möglichkeit bestimmte, häufig genutzte Aktionen, schneller auszuführen. Diese Regel wird in der Steuerung durch die Möglichkeit ermöglicht, den Lieferstandort und Roboter sowohl über die Karte als auch über einen Input und eine Dropdownliste auswählen zu können. Im Editiermodus gibt es die Shortcuts zum rückgängig machen und wiederhohlen.

% Die achte Regel, die eine minimalistische Benutzeroberfläche erwartet, ist nur subjektiv bewertbar. Mithilfe der Usability Tests kann gut bewertet werden, welche Informationen und Elemente irrelevant sind oder selten gebraucht werden und dadurch überflüssig sind.

% Laut der neunten Regel sollten Fehlermeldungen in einfacher Sparche formuliert sei, das Problem präzise beschreiben und konstruktiv eine Lösung vorschlagen. Hierfür gibt es verschiedene Dialoge die bei Fehlermeldungen angezeigt werden.

% Die zehnte Regel sagt aus, dass es, wenn nötig eine Dokumentation geben sollte, mithilfe welcher die Benutzer ihre Aufgaben verstehen und Abschließen können. Die Anwendung wurde mit dem Ziel entwickelt selbsterklärend zu sein. 
% Dieses Ziel noch irgendwo zu Beginn erwähnen
% Außerdem gibt es Tooltips für bestimmte Statusinformationen und beim Ändern von Einstellungen gibt es Bestätigungsdialoge mit Erklärungen. Mithilfe der Usability Tests kann geprüft werden, ob das Ziel erfüllt werden konnte oder ob weitere Erklärungen nötig sind.

Auch die anderen Usability Entscheidungsregeln wurden während der Entwicklung beachtet und weitestgehend erfüllt, was nicht automatisch bedeutet, dass der Prototyp auch wirklich benutzerfreundlich ist. Um das zu überprüfen, folgen die Usability Tests.

\paragraph{Usability Tests}
Während eines Großteils der Implementierung wurden die Usability Tests nur sehr oberflächig durch den Entwickler selbst durchgeführt. So wurde während der Entwicklung Zeit gespart, gleichzeitig wurde aber nur mit einem sehr groben Filter getestet, sodass viele Probleme nicht identifiziert werden konnten. Aus diesem Grund wurden Usability Tests mit ausgewählten Testpersonen durchgeführt, nachdem alle Funktionen des Prototyps umgesetzt wurden.

Der Aufbau der ausführlicheren Usability Tests basiert maßgeblich auf verschiedenen Artikeln der Nielsen Norman Group. So wurden die Aufgaben nach dem Stepped User Tasks System \cite{Pernice.2020} formuliert und während der Durchführung der Tests wurde darauf geachtet, dass die Testpersonen die Thinking-Aloud-Methode \cite{Nielsen.2012b} einsetzen. Die ausführlicheren Tests wurden in zwei Runden mit jeweils fünf Personen durchgeführt. So konnten die gefundenen Probleme nach der ersten Runde behoben werden, bevor die zweite Runde durchgeführt wurde. Für die Usability Tests wurden drei Aktivitäten vorbereitet, die die Testpersonen nacheinander durchführen sollten. Die Aktivitäten decken direkt oder indirekt einen großen Teil der Funktionen des Prototyps ab. Konkret beschäftigen sich die Aktivitäten mit der Übersicht, der Steuerung und dem Editiermodus. So müssen in der ersten Aktivität Position und der Akkustand eines bestimmten Roboters gefunden werden. Daraufhin muss der Roboter in der zweiten Aktivität zu einem oder mehreren Standorten und dann zurück zur Ladestation geschickt werden. In der dritten Aktivität muss ein 3D-Modell mithilfe des Editiermodus richtig positioniert werden. In der dritten Aktivtiät wird beispielsweise nicht nur geprüft wie Benutzerfreundlich das Editieren ist, sondern wie leicht der Editiermodus überhaupt gefunden werden kann. Eine genauere Beschreibung der Aktivitäten ist im Anhang aufgelistet.
% TODO Anhang hinzufügen

Um die geplanten Aktivitäten zu prüfen wurde zunächst ein Pilottest (Test 0) durchgeführt.
Mithilfe von Pilottests können Probleme mit den geplanten Aktivitäten gefunden werden, sodass diese vor der Durchführung der richtigen Tests aus dem Weg geschaffen werden können \cite{Schade.2015}.
Mithilfe des Pilottests konnten die Aktivitäten optimiert werden. Außerdem konnten die Ergebnisse des Pilottests bezüglich der Usability des Prototyps ausgewertet werden, sodass viele Probleme behoben werden konnten, bevor die restlichen richtigen Tests durchgeführt wurden.

\paragraph{Erste Usability Test Runde}

In den beiden folgenden Tabellen werden die Ergebnisse des ersten Usability Test durchlaufs zusammengefasst. Der Pilottest wird hierbei zu dieser Runde dazugezählt. Hierbei handelt es sich in den beiden Tabellen um die T0 Spalte. In Tabelle \ref{tbl:1stUsabilityTestsProblems} wird dargestellt, welche Probleme bei welcher Testperson aufgefallen sind. So sieht man, dass die meisten Probleme die im Pilottest aufgefallen sind, danach nicht mehr aufgetreten sind, was darauf zurückzuführen ist, dass diese vor der Durchführung der restlichen Tests behoben wurden. Man kann zudem sehen, dass den meisten Testpersonen mindestens ein Problem aufgefallen ist, das keiner anderen Testperson aufgefallen ist. Hierdurch zeigt sich, dass durch weniger Testpersonen wahrscheinlich weniger Probleme gefunden worden wären. Bei der Korrektur der Probleme wurden die Probleme priorisiert, die besonders vielen Testpersonen aufgefallen sind. Bei den Usability Tests gab es außerdem Feedback von den Testpersonen, welches nicht als Probleme eingestuft wurde, aber trotzdem bei der Implementierung berücksichtigt wurde.

\begin{table}[H]
    \caption{Gefundene Probleme in erster Usability Test Runde}\label{tbl:1stUsabilityTestsProblems}
    \begin{tabular}{l||l|l|l|l|l|l}
                & T0    & T1    & T2    & T3    & T4    & T5    \\ \hline
    Problem 1   & X     &       &       & X     &       &       \\
    Problem 2   & X     &       &       &       &       &       \\
    Problem 3   & X     &       &       &       &       &       \\
    Problem 4   & X     &       &       &       &       &       \\
    Problem 5   & X     &       &       &       &       &       \\
    Problem 6   & X     &       & X     &       &       &       \\
    Problem 7   & X     &       &       &       &       &       \\
    Problem 8   & X     &       &       &       & X     &       \\
    Problem 9   &       & X     &       &       &       &       \\
    Problem 10  &       & X     &       &       &       &       \\
    Problem 11  &       & X     & X     & X     & X     &       \\
    Problem 12  & X     & X     & X     &       &       &       \\
    Problem 13  &       &       & X     &       &       &       \\
    Problem 14  &       &       & X     & X     &       &       \\
    Problem 15  & X     &       & X     &       &       &       \\
    Problem 16  &       &       &       & X     &       &       \\
    Problem 17  &       &       &       & X     &       &       \\
    Problem 18  &       &       &       &       &       & X     \\
    Problem 19  &       &       &       &       &       & X     \\
    Problem 20  &       &       &       &       &       & X     \\
    \end{tabular}    
\end{table}

In Tabelle \ref{tbl:1stUsabilityTestsActions} sind die Aktivitäten in verschiedene Aktionen aufgeteilt, die bei der Ausführung der Aktivität vorkommen können, aber nicht unbedingt vorkommen müssen. Die Werte zeigen, wie gut eine Aktion von einer Testperson durchgeführt werden konnte. Je niedriger der Wert, desto weniger Probleme sind aufgetreten. Kein Wert bedeutet, dass die Testperson die Aktion nicht durchgeführt hat, da die Aktion nicht benötigt wurde. Somit wird gezeigt wie gut die Usability in den entsprechenden Teilen der Anwendung ist. Man sieht, dass die meisten Aktionen nach dem Pilottest deutlich besser durchgeführt werden konnten, was auf die Anpassungen des Prototyps nach dem Pilottest zurückzuführen ist. Dass sich die Fragestellungen der Aktivitäten zwischen Pilottest und den anderen Tests teilweise etwas unterscheiden spielt auch eine signifikante Rolle. Tabelle \ref{tbl:1stUsabilityTestsActions} zeigt, dass die meisten Aktionen zuverlässig durchgeführt werden können, sie zeigt aber auch, dass die Benutzerfreundlichkeit an einigen Stellen noch ausbaufähig ist. Insbesondere der Editiermodus hat Mängel, aber auch in der Übersicht und Steuerung gibt es kleinere Probleme.


\begin{table}[H]
    \caption{Bewertung der durchgeführten Aktionen in erster Usability Test Runde}\label{tbl:1stUsabilityTestsActions}
    \begin{tabular}{l||llllll}
        Aktion                              & T0        & T1        & T2        & T3        & T4        & T5        \\ \hline
        \textbf{Aktivität 1 (Übersicht)}    &           &           &           &           &           &           \\
        Roboter mit Button ausgewählt       &         1 &         1 &         1 &         1 &         1 &         1 \\
        Akkustand gefunden                  &         2 &         1 &         1 &         2 &         2 &         1 \\
        Roboter mit Folgen-Button gefunden  &         2 &         1 &         1 &         - &         - &         - \\
        Roboter mit Karte gefunden          &         - &         - &         - &         2 &         1 &         1 \\ \hline

        \textbf{Aktivtiät 2 (Steuerung)}    &           &           &           &           &           &           \\
        Lieferauftrag-Button gefunden       &         1 &         1 &         1 &         1 &         1 &         1 \\
%       Roboter mit Karte ausgewäht         &         - &         - &         - &         - &         - &         1 \\
        Standort mit Personfinder ausgewählt&         2 &         - &         1 &         1 &         1 &         1 \\
        Standort mit Karte ausgewählt       &         - &         1 &         - &         - &         1 &         1 \\
        Lieferauftrag gestartet             &         3 &         2 &         1 &         1 &         1 &         1 \\
        Roboter zur Ladestation geschickt   &         - &         1 &         1 &         1 &         1 &         1 \\ \hline

        \textbf{Aktivität 3 (Editiermodus)} &           &           &           &           &           &           \\
        Editormodus über Adminansicht       &         3 &         - &         - &         - &         - &         - \\
        Editormodus über Nutzeransicht      &         - &         1 &         1 &         1 &         1 &         1 \\
        Steuerung verstanden                &         - &         1 &         3 &         1 &         2 &         1 \\
        Undo/Redo genutzt                   &         - &         - &         - &         - &         - &         - \\
        Modell positioniert                 &         2 &         1 &         2 &         1 &         1 &         1 \\
    \end{tabular}
\end{table}


\paragraph{Zweite Usability Tests Runde}

Die Ergebnisse der ersten Usability Tests Runde wurden in der darauffolgenden Implementierungsphase einbezogen. Verschiedene Probleme wurden behoben und Feedback wurde umgesetzt. Daraufhin wurde eine neue Runde an Usability Tests mit fünf neuen Testpersonen durchgeführt. Die Ergebnisse sind in den folgenden zwei Tabellen abgebildet. Die Tabellen folgen der Struktur der vorherigen Tabellen. So zeigt Tabelle \ref{tbl:2ndUsabilityTestsProblems}, welche Testperson welche Probleme hatte und Tabelle \ref{tbl:2ndUsabilityTestsActions} wie gut Aktionen durchgeführt werden konnten. Man sieht in Tabelle \ref{tbl:2ndUsabilityTestsProblems}, dass deutlich weniger Probleme aufgefallen sind. Neben den Problemen gab es auch noch weiteres Feedback, dass sich aber vor allem auf Rechtschreibung, Zeichensetzung und Benennung beschränkt. Außerdem ist aus dem Feedback erkenntlich, dass das erste Auffinden von bestimmten Funktion etwas dauern kann, die Bedienung dieser Funktionen dann aber einwandfrei funktioniert. Es ist zu erwarten, dass die Bedienung des Prototyps bei einer erneuten Nutzung deutlich leichter ist, da die Funktionen dann nicht mehr lange gesucht werden müssen. Auch in Tabelle \ref{tbl:2ndUsabilityTestsActions} fällt auf, dass deutlich weniger Probleme aufgetreten sind. So gab es nur bei der zweiten und fünften Testperson geringfügige bis erhebliche Probleme. Bei der zweiten Testperson wurde erst versucht den Roboter direkt über eine Auswahl auf der Karte zur Ladestation zu schicken, während die fünfte Testperson Probleme damit hatte den Editiermodus zu finden, wobei hierfür ohne Erfolg in der Verwaltungsansicht gesucht wurde, bevor der Editiermodus in der Nutzeransicht gefunden wurde. Nachdem die Tests ausgewertet wurden, wurde der Prototyp angepasst, sodass die beiden genannten Probleme nicht mehr auftreten sollten. Auch die in \ref{tbl:2ndUsabilityTestsProblems} aufgelisteten Probleme wurden behoben.

\begin{table}[H]
    \caption{Gefundene Probleme in zweiter Usability Test Runde}\label{tbl:2ndUsabilityTestsProblems}
    \begin{tabular}{l||l|l|l|l|l|l}
                    & T1    & T2    & T3    & T4    & T5    \\ \hline
        % Beim entfernen der Roboter Auswahl wird fälschlicherweise in das Stockwerk des Roboters gewechselt bei dem die Auswahl entfernt wurde
        Problem 1   & X     &       &       &       &       \\
        % Steuerungsbuttons müssen nicht immer aktiv sein (Abbrechen, wenn kein Lieferauftrag existiert; Laden, wenn bereits geladen wird)
        Problem 2   & X     &       &       &       &       \\
        % Roboter kann nicht über die Karte (ohne den "zur Ladestation" Button) zur Ladestation geschickt werden
        Problem 3   &       & X     &       &       &       \\
        % Suchfunktion von Standorten wurde nicht gefunden, weil diese im Lieferauftrag versteckt ist
        Problem 4   &       &       & X     &       &       \\
        % Irritation, dass Erklärung der Steuerung im Tooltip steht und nicht einfach permanent angezeigt an einer anderen Position angezeigt wird
        Problem 5   &       &       &       & X     &       \\
        % Editiermodus im Adminmodus nicht gefunden
        Problem 6   &       &       &       &       & X     \\
        % Editiermodus im Nutzermodus nicht gefunden
        Problem 7   &       &       &       &       & X     \\
    \end{tabular}    
\end{table}

\begin{table}[H]
    \caption{Bewertung der durchgeführten Aktionen in zweiter Usability Test Runde}\label{tbl:2ndUsabilityTestsActions}
    \begin{tabular}{l||llllll}
        Aktion                              & T1    & T2    & T3    & T4    & T5    \\ \hline
        \textbf{Aktivität 1 (Übersicht)}    &       &       &       &       &       \\
        Roboter mit Button ausgewählt       & 1     & 1     & 1     & 1     & 1     \\
        Akkustand gefunden                  & 1     & 1     & 1     & 1     & 1     \\
        Roboter mit Folgen-Button gefunden  & -     & -     & -     & -     & -     \\
        Roboter mit Karte gefunden          & 1     & 1     & 1     & 1     & 1     \\ \hline
        \textbf{Aktivtiät - (Steuerung)}    &       &       &       &       &       \\
        Lieferauftrag-Button gefunden       & 1     & -     & -     & -     & 1     \\
%       Roboter mit Karte ausgewäht         & -     & -     & -     & -     & -     \\
        Standort mit Personfinder ausgewählt& 1     & -     & -     & -     & 1     \\
        Standort mit Karte ausgewählt       & -     & 1     & 1     & 1     & -     \\
        Lieferauftrag gestartet             & 1     & 1     & 1     & 1     & 1     \\
        Roboter zur Ladestation geschickt   & 1     & 2     & 1     & 1     & 1     \\ \hline
        \textbf{Aktivität 3 (Editiermodus)} &       &       &       &       &       \\
        Editormodus über Adminansicht       & -     & -     & -     & -     & 3     \\
        Editormodus über Nutzeransicht      & 1     & 1     & 1     & 1     & 2     \\
        Steuerung verstanden                & 1     & 1     & 1     & 1     & 1     \\
        Undo/Redo genutzt                   & -     & -     & 1     & -     & 1     \\
        Modell positioniert                 & 1     & 1     & 1     & 1     & 1     \\
    \end{tabular}
\end{table}

Da die Menge der gefundenen Probleme mit dem zweiten Durchlauf der Tests stark abgenommen hat, wurde auf einen dritten Durchlauf verzichtet. Es ist nicht zu erwarten, dass diese den Aufwand Wert sind, da aufgrund der Ergebnisse der vorherigen Tests angenommen werden kann, dass nur noch wenige Probleme bestehen, die auch mit einem erneuten Durchlauf nicht unbedingt gefunden werden können. Es ist wichtig zu beachten, dass mit den Usability Tests nicht alle Funktionen des Prototyps getestet wurden. Stattdessen wurden nur die wichtigsten Funktionen getestet die mit \deckgl in Verbindung stehen und somit für die Forschungsfrage große relevanz haben. Ob die Liste der Roboter und Stockwerke in der Verwaltungsansicht besonders Benutzerfreundlich ist, ist nicht so relevant, da diese Liste sehr simpel ist und keine besonderen Technologien nutzt.
% TODO Bessere Formulierung der letzten Sätze finden
In Kombination mit der Einhaltung der Usability Entscheidungsregeln ist davon auszugehen, dass das Ziel der Benutzerfreundlichkeit ausreichend erfüllt wurde.

\subsubsection{Performance}
% Metriken kurz erklären
% First Contentful Paint
% Largest Contentfult Paint => Nicht nutzbar, da das Rendern der deck.gl Layers nicht über Events erkannt werden kann
% First Input Delay
% Total Blocking Time
% Erläutern warum die Richtwerte nicht erreicht werden können, die Performance aber trotzdem in Ordnung ist



% => Performance Tests (testen welche Maßnahmen welche Performance Auswirkungen haben)
% Maßnahmen
% Nutzung des .glb Formats statt .obj (beides mit und ohne Kompression)
    % Einfluss auf Ladezeiten (Netzwerk und Rendering)
    % Einfluss auf GPU und CPU Auslastung
% Caching der Robotermodelle
% Caching aller anderen Anfragen (Bis auf Roboter)
% Sehr Kurzzeitiges Caching der Roboter
% Initialisierung der Karten Vorschau über Button statt beim Öffnen des Aufklappers (vielleicht nicht ganz passend?)
