\newpage
\section{Umsetzung}
Im Folgenden wird die Implementierung, sowie die Evaluierung des Prototyps beschrieben.

Bei der Skizzierung der Mockups und auch später während der Implementierung wurde darauf geachtet eine gute Benutzerfreundlichkeit zu bieten. Hierfür wurde sich an den 1994 von Nielsen entwickelten 10 Usability Heuristics orientiert.
% Quelle Nielsen https://www.nngroup.com/articles/ten-usability-heuristics/
In der Evaluierung des Prototyps werden die Heuristics vorgestellt und es wird genauer geprüft wie gut diese eingehalten wurden.
% Verweis auf Abschnitt

Fehlender-Text

\subsection{Mockup}

Für den Prototyp wurden Mockups skizziert an denen sich während der Implementierung orientiert werden konnte. Diese Mockups wurden zunächst auf Papier niedergeschrieben. Für die folgende Beschreibung wurden die Mockups mithilfe von Figma digitalisiert.
% Figma Quelle
Es gibt jeweils ein Mockup für die Übersicht, Steuerung und Verwaltung. 

In der Übersicht werden die Gebäudemodelle in Kombination mit den Roboterdaten angezeigt. So werden die verschiedene Standorte mithilfe von Icons markiert, die Roboterpfade werden über Linien dargestellt und die Roboterpositionen werden mithilfe von 3D-Modellen der Roboter angezeigt. Es gibt Buttons mit denen zwischen den verschiedenen Stockwerken navigiert werden kann. Die Roboter können über das Anklicken des entsprechenden 3D-Modells und über Buttons markiert werden. Über einen weiteren Button kann dem markierten Roboter dann automatisch gefolgt werden. Über einen weiteren Button kann die Kameraposition wieder auf die Ausgansposition zurückgesetzt werden.

Die Steuerung erweitert die Übersicht um weitere Funktionen. So kann man nach dem Markieren eines Roboters weitere Buttons nutzen. Über diese kann man Lieferrouten bestimmen, den Roboter zum Aufladen zur Ladestation schicken, oder den aktuellen Lieferauftrag abbrechen. Für die Routenbestimmung muss ein Ziel und ein Roboter ausgewählt werden. Auch können optional ein Ausgabepunkt und Zwischenstationen eingestellt werden. Um die Routenerstellung zu vereinfachen, können sowohl Roboter als auch Standorte über das Anklicken auf der Karte ausgewählt werden.

In der Verwaltungsansicht gibt es eine Übersicht über die existierenden Roboter und Stockwerke. So gibt es zum einen eine Liste der existierenden Roboter, über die man Zugriff auf verschiedene Informationen hat. So sind hier unter anderem auch Informationen ersichtlich, auf die man wegen fehlender Berechtigungen in den anderen Anischten keinen Zugriff hat. Hierbei handelt es sich um Informationen wie die Systeminterne \ac{ID} und die Neustart-Zeit des Roboters. Über diese Liste lassen sich zusätzlich auch Einstellungen der Roboter ändern. So hat der Administrator hier beispielsweise die Möglichkeite den Namen, den Ausgabepunkt oder die Ladestation des Roboters zu ändern. Auch gibt es hier eine Vorschau der Gebäudekarte, in der die genaue Position des Roboters ersichtlich ist.

In der Übersicht der Stockwerke gibt es für jedes Stockwerk eine Liste der Standorte. Außerdem gibt es wie bei den Robotern eine Vorschau der Karte. Zusätzlich gibt es ein Kontextmenü, über das in den Editiermodus des Stockwerks gewechselt werden kann. Da die Funktionalitäten und der Aufbau des Editiermodus stark von den verfügbaren Funktionen in \deckgl{} abhängig ist, wurde hierfür kein Mockup entwickelt. So existieren nur die Anforderungen, dass die Roboterdaten und 3D-Modelle durch Verschieben und Rotieren der Objekte synchronisiert werden können.  

\subsection{Implementierung}
% ggf. wird ein weiteres Prototyp-Backend erstellt in dem die Daten abgespeichert werden, die aktuell hard-coded sind. Falls dieses Backend erstellt wird, sollte das hier noch erwähnt werden
Es wurde ein Frontend entwickelt, dass auf das \ac{BCB} zugreift, um die Roboterdaten anzufragen. Wie das \ac{BCB} mit den Robotern kommuniziert, wurde in einem vorherigen Kapitel erklärt. % Referenz auf dieses Kapitel?
Das Frontend nutzt das Web-Framework React JS in Kombination mit HTML, SCSS und Typescript. Typscript wurde aufgrund der statischen Typisierung, frühzeitigen Fehlererkennung und besseren Wartbarkeit gegenüber Javascript gewählt. Da SCSS eine bessere Übersichtlichkeit der Stylesheets ermöglicht, wurde es statt CSS eingesetzt. Zustandsinformationen die Komponentenübergreifend abgerufen werden, werden zentral mithilfe von React-Redux gespeichert. Die Grundstruktur des Frontend-Projekts wurde mihilfe des Shell Befehls "npx create-chayns-app" generiert. Die Kompilierung ist mithile des npm-Pakets "chayns-toolkit" konfiguriert. GUI-Elemente wie Buttons und Aufklapper werden durch die Komponentenbibliothek "chayns-components" bereitgestellt. Ein großer Teil der Typscript Type-Definitionen konnte aus einem anderen Frontend-Projekt kopiert werden. Hierbei handelt es sich um Types für Objekte, die aus dem \ac{BCB} stammen werden. Außerdem werden die npm-Pakete "clsx" und "fortawesome" eingesetzt.
% TODO Acronyme und Glossar Einträge ergänzen
% TODO genauer auf Pakete eingehen die nicht in den Grundlagen erläutert werden

\subsubsection{Übersicht}
In der Übersicht werden die Roboterdaten in Kombination mit den Gebäudemodellen mithilfe von \deckgl{} angezeigt. Hierfür werden verschiedene \deckgl{}-Layers eingesetzt.

\paragraph{Gebäudemodelle}
Für den Prototyp sind die \ac{URL} der 3D-Modelle hartkodiert und verweisen auf den chayns.space in dem die Modelle abgespeichert sind. Die Gebäudemodelle werden aus bereits erläuterten Gründen im \ac{glTF}-Format geladen und in der ScenegraphLayer angezeigt. Die ScenegraphLayer ist dafür ausgelegt, ein bestimmtes 3D-Modell beliebig oft an verschiedenen Positionen anzuzeigen. Diese Verwendung der ScenegraphLayer ist auf die eigentliche Aufgabe von \deckgl{} - die Visualisierung riesiger Geodaten Mengen - zurückzuführen. Aus diesem Grund muss für jedes 3D-Modell eine eigene Instanz der ScenegraphLayer erzeugt werden. 
% TODO Quelle Scenegraph Layer Doku
\deckgl{} ist für den Einsatz von über 100 Ebenen gleichzeitig ausgelegt, wobei wahrscheinlich sogar der einsatz von bis zu 1000 Ebenen ohne große Performance Einbußen möglich ist. Da nicht davon auszugehen ist, dass ein angezeigtes Stockwerk aus mehr als 10 3D-Modellen und somit 10 ScenegraphLayers besteht, sind keine relevanten negativen Performance-Auswirkungen zu erwarten.
% TODO Quelle deckgl zu Layers (https://deck.gl/docs/developer-guide/performance#number-of-layers)
Für die Scenegraph-Layers ist das Backface Culling aktiviert. Hierdurch werden die Rückseiten der Polygone - und somit die von der Kamera abgewandten Zimmerdecken und Wände - durchsichtig, sodass der Nutzer von außen in die Räume hinein sehen kann. 
% TODO Quelle Backface Culling
% TODO Schaubild mit und ohne Backface Culling => Schaubild erwähnen
Außerdem ist für die ScenegraphLayers das \ac{PBR} Lighting aktiviert. \ac{PBR} bestimmt die Lichtverhältnisse, abhängig des Materials eines 3D-Modells. Hierdurch wird die Qualität des angezeigten Modells erhöht.
% TODO Erwähnen falls 3D-Modelle gecached werden

\paragraph{Roboterdaten}
Die Roboterdaten werden über verschiedene Endpunkte des \ac{BCB}s abgerufen. So gibt es einen Endpunkt für die Bezeichnungen der verschiedenen Standorte und einen Endpunkt für den Roboterstatus, Lieferautrag und die Roboterposition.
% TODO Quelle zur Swagger Doku
Für die Positionen aller Standorte und der Roboterpfade gibt es keinen Endpunkt. Stattdessen können die Standorte und Pfade nur von Stockwerken angefragt werden, in denen sich Roboter zu dem Zeitpunkt befinden, da diese Daten direkt von den Robotern angefragt werden. Damit immer alle Daten aus allen Stockwerken abgerufen werden können, sind diese im Prototyp für alle Stockwerke hartkodiert. Für eine potenzielle Live-Anwendung müssten diese Daten in der Datenbank des \ac{BCB}s gespeichert und regelmäßig mit den Robotern synchronisiert werden.
% TODO Schaubild in dem Datenbankstruktur um die entsprechende Tabelle erweitert wird => genauer darauf eingehen.

Im Gegensatz zu den Gebäuademodellen werden die Robotermodelle im \ac{OBJ}-Format mit der SimpleMeshLayer angezeigt. Mit der ScenegraphLayer gibt es verschiedene Probleme, wodurch die SimpleMeshLayer brauchbarer, aber auch nicht ideal, ist. So können die Positionen der Roboter in der ScenegraphLayer nicht animiert werden. Auch gibt es mit der ScenegraphLayer Probleme bei der erneuten Initialisierung einer Layer, wodurch die 3D-Modelle nicht erneut angezeigt werden können, nachdem diese ausgeblendet wurden. Bei beiden Problemen handelt es sich wahrscheinlich um Bugs in \deckgl{}, denn zumindest das Animieren der ScenegraphLayer sollte laut der Dokumentation möglich sein. 
% Quelle ScenegraphLayer
Wie bereits erwähnt, lässt sich die Materialdatei des \ac{OBJ} Formats nicht in der SimpleMeshLayer einbinden, weshalb die Roboter einfarbig angezeigt werden müssen. Das ist nicht unbedingt ein Nachteil, denn so können die Roboter mithilfe einer herausstechenden Farbe für den Nutzer besser sichtbarer gemacht werden. Die Positionsänderungen der Roboter werden über die transitions Property animiert. Allerdings lässt sich die Rotation nicht animieren, was vermutlich auch auf einen Bug in \deckgl{} zurückzuführen ist.

Über den Robotermodellen wird mithilfe der IconLayer der aktuelle Status der Roboter angezeigt. In einer IconLayer Instanz können im Gegensatz zur ScenegraphLayer verschiedene Icons angezeigt werden, weshalb hierfür eine Layer-Instanz ausreicht. 
% Quelle IconLayer Doku
So schwebt über jedem Roboter ein eigenes Icon. Die genutzten Icons stammen aus der Icon-Bibliothek Fontawesome und werden aus dem "fortawesome" npm-Paket als \ac{SVG} importiert.
% TODO Quelle für genutzte Funktion.
Da die IconLayer keine \ac{SVG}-Dateien anzeigen kann, werden die SVG-Dateien in Data-URLs umgewandelt.
% Quelle IconLayer Doku.

Die verschiedenen Standorte - Lieferpunkte, Ausgabepunkte und Ladestationen - werden auch über die IconLayer angezeigt. Wie bei den Roboter-Zuständen werden hierfür verschiedene Fontawesome-Icons genutzt. Wurde ein Roboter ausgewählt und hat dieser einen Lieferauftrag, dann wird der Zielstandort farbig markiert. Die Pfade und virtuellen Wände werden über die PathLayer angezeigt. 
% TODO Quelle PathLayer Doku
Die virtuellen Wände werden gestrichelt angezeigt, um diese von den Roboterpfaden zu unterscheiden. Hierfür wird die PathStyleExtension genutzt.
% TODO Quelle (https://deck.gl/docs/api-reference/extensions/path-style-extension)
Es reicht eine PathLayer-Instanz aus, um sowohl Roboterpfade als auch virtuelle Wände anzuzeigen.

Bei der folgenden Anwendung handelt es sich um einen Screenshot des Prototyps. Man sieht alle erwähnten Ebenen. So sieht man ein Gebäudemodell, ein Roboter mit einem Icon, das den Status repräsentiert, verschiedene Pfade und verschiedene Standorte.
% TODO Screenshot hinzufügen 

\paragraph{Echtzeit-Aktualisierung}
% TODO Websocket erwähnen
Die Positionen sowie weitere Statusinformationen der Roboter, wie beispielsweise der aktuelle Auftrag und Akkuladung, werden mithilfe einer indirekten \gls{Websocket}-Verbindung zwischen der Webanwendung und dem \ac{BCB} regelmäßig aktualisiert. Hierfür wird der für chayns interne \gls{Websocket}-Service genutzt. In der folgenden Abbildung ist Funktionsweise des \gls{Websocket}-Services vereinfacht dargestellt. Aktualisiert ein Roboter seine Position, wird die entsprechende Information über \gls{MQTT} an das \ac{BCB} gesendet.
% Passt das so? Funktioniert MQTT wie beschrieben?
Das \ac{BCB} sendet daraufhin eine Nachricht an den \gls{Websocket}-Service, der diese Information wiederum an alle verbundenen Clients schickt.
% TODO Schaubild einfügen.

Die über den \gls{Websocket}-Service empfangenen aktualisierten Informationen werden zentral im Redux-Store aktualisiert, sodass dem Nutzer die aktualisierten Informationen direkt angezeigt werden können. Bei Positonsänderungen der Roboter werden mithilfe des transitions Attributs der SimpleMeshLayer und der IconLayer animiert. So entsteht der Eindruck, dass die Roboter zusammen mit den Status-Icons fahren. Wie bereits erwähnt lässt sich für die Robotermodelle allerdings nur die Position und nicht die Rotation animieren.

\paragraph{Interaktion}
Die Roboter, sowie die Standorte sind, mithilfe der onClick Property der entsprechenden Ebene, auswählbar.
% onClick Quelle
Ausgewählte Standorte und Roboter werden verfärbt angezeigt. Außerdem erscheint ein Button über den sich weitere Informationen wie beispielsweise die Akkuladung bei Robotern und der Name bei Standorten anzeigen lässt. Schwebt die Maus über einem Standort oder Roboter, dann wird mithilfe der getTooltip Property ein Tooltip angezeigt, in dem der Name des entsprechenen Objekts steht.
% getTooltip Quelle
Es gibt zudem die Möglichkeit einem Roboter zu Folgen. Die Kamera wird hierfür mithilfe des FlyToInterpolators zu dem ausgewählten Roboter bewegt. 
% FlyToInterpolators Quelle
Während einem Roboter gefolgt wird, wird die Kameraposition mithilfe der transitionDuration Property animiert, wenn die Roboterposition aktualisiert wird.
% transitionDuration Quelle


\subsubsection{Steuerung}
Es gibt drei verschiedene Aktionen zum Steuern der Roboter: Lieferauftrag, Laden und Abbrechen. Mit dem Laden und Abbrechen wird der aktuelle Lieferauftrag abgebrochen, worauf der Nutzer auch hingewiesen wird. Für beide Aktionen gibt es jeweils einen Button, der klickbar ist, sobald ein Roboter ausgewählt wurde. Während der Roboter durch das Laden zur Ladestation fährt, bewegt sich der Roboter durch Abbrechen nicht mehr. Für das Einstellen eines Lieferauftrags muss ein Ziel und ein Roboter, sowie optional ein Ausgabepunkt und Zwischenstationen ausgewählt werden. Hierfür gibt es zum einen Inputs, mit denen nach Standorten und Robotern gesucht werden kann. Bei den Inputs handelt es sich um die PersonFinder-Komponente der chayns-components, die eigentlich für das Suchen nach chayns Nutzern genutzt wird. Im Prototyp ist die Komponente für das Suchen nach Standorten entsprechend konfiguriert.
% TODO PersonFinder Doku

Auch lassen sich Standorte und Roboter mit der Auswahl über die Karte festlegen. Die Roboter können zudem über ihre Buttons ausgewählt werden. Bei der Auswahl der entsprechenden Standorte sind ungültige Standorte auf der Karte ausgegraut und nicht auswählbar. So kann weder als Ausgabepunkt noch als Zielpunkt eine Tür oder ein Fahrstuhl angegeben werden. Als Ausgabepunkt kann währneddessen beispielsweise kein Zielpunkt ausgewählt werden. Zum entgültigen Ausführen der drei Aktionen wird der entsprechende Endpunkt im \ac{BCB} aufgerufen.
% TODO Quelle zur Doku aller drei Endpunkte

\subsubsection{Verwaltungsansicht}
Die Verwaltungsansicht ist nicht besonder komplex, da die Daten der Roboter und Stockwerke sauber strukturiert sind und somit leicht mithilfe von React gemappt werden können.

In der Roboterliste werden im Gegensatz zum Mockup mehr Statusinformationen der Roboter angezeigt. Auch können mehr Einstellungen der Roboter geändert werden. Da die Übersicht über die verschiedenen Standorte auch über die Liste der Stockwerke ersichtlich ist und dadurch redundant ist, ist diese nicht in der Roboterliste vorhanden. Stattdessen gibt es einen Button, über den man vom Roboter zum entsprechenden Stockwerk in der Stockwerk-Liste navigieren kann. Die Stockwerkliste unterscheidet sich nur geringfügig vom Mockup. So werden die Standorte im Gegensatz zum Mockup gruppiert nach der Art des Standorts aufgelistet. Der Grund hierfür ist, dass die Art des Standortes nicht aus dem Namen ersichtlich sein muss. Entsprechend gibt es eine bessere Übersichtlichkeit über die verschiedenen Standorte als im Mockup.

In beiden Listen gibt es eine Vorschau des entsprechenden Stockwerks, um die Position des Roboters oder der Standorte zu zeigen. Hierbei handelt es sich um die Nutzeransicht mit weniger Funktionalitäten. Die Vorschau ist im Mockup automatisch geöffnet, was ein Problem ist, da die entsprechende \deckgl{}-Karteninstanz - aufgrund des Verhaltens der genutzten Aufklapper-Komponente - beim Öffnen des Aufklappers initialisiert wird. Die Initialisierung der \deckgl{}-Karteninstanz ist rechnerisch aufwändig und verursacht dadurch beim ersten Öffnen des Aufklappers starke Ruckler. Um dieses Verhalten zu verbessern wird stattdessen ein Button angezeigt, über den die Karte manuell initialisiert werden kann. Dadurch gibt es die Ruckler erst beim Klicken des Buttons und nicht beim Öffnen des Aufklappers, was weniger störend ist.

Bei jedem Stockwerk gibt es die Möglichkeit in den Editiermodus zu navigieren.

\subsubsection{Editiermodus}
Wie bereits erwähnt müssen die Roboterdaten mit den 3D-Modellen manuell synchronisiert werden. Hierfür gibt es einen Editiermodus. In diesem wird die Nutzeransicht mit Editiermöglichkeiten angezeigt. Da der Einsatz der Steuerungs- und Umschalttaste nötig ist, kann dieser Modus nicht an Mobilgeräten genutzt werden. Im Editiermodus hat der Nutzer die Möglichkeit neue 3D-Modelle zu importieren. Hierfür gibt es einen einfachen Dateiinput der nur Dateien im \glb{} Format erlaubt. Wie bereits erwähnt sind die 3D-Modelle im Prototyp hartkodiert. Entsprechend werden Änderungen sowie neu importierte 3D-Modelle nur für die aktuelle Sitzung gespeichert und gehen verloren, wenn die Anwendung und somit eine neue Sitzung erneut geöffnet wird. Mithilfe der in \deckgl{} integrierten Events onDragStart, onDrag und onDragEnd kann das angeklickte 3D-Modell per Ziehen der Maus verschoben und rotiert werden.
% TODO Quelle für erwähnte Events
So wird das ausgewählte Modell beim Ziehen entweder verschoben oder rotiert, je nachdem ob die Steuerungs- oder Umschalttaste gedrückt wurden. Das Verschieben und Rotieren kann mithilfe der Tastenkombination Strg + Z rückgängig gemacht und mit Strg + Y wiederholt werden. Hierfür wurden zwei Stapel implementiert in denen die vergangenen und rückgängiggemachten Aktionen gespeichert werden.

Der Boden der 3D-Modelle liegt relativ konstant auf der z-Koordinate 0. Auf der z-Achse wird die vertikale Position gespeichert. Aufgrund der Ungenauigkeiten die durch den \ac{LiDAR}-Scan entstehen ist der Boden aber nicht vollständig eben. Da die Roboterdaten zweidimensional und somit keinen Höhenwert haben besteht die Gefahr, dass diese an manchen Stellen unter dem Boden der 3D-Modelle verschwinden. Aus diesem Grund werden die Roboterdaten an einer erhöhten z-Koordinate positioniert. Da der Boden bei allen 3D-Modellen an derselben z-Koordinate positioniert ist, müssen diese durch den Nutzer nicht weiter an der z-Achse verschoben werden. Im Vergleich zu den Roboterdaten sind die 3D-Modelle immer um 90° an der z-Achse und einen beliebigen Wert an der y-Achse rotiert. Die Rotation der x-Achse stimmt zwischen 3D-Modellen und Roboterdaten bereits überein. Die 3D-Modelle werden automatisch um -90° an der z-Achse rotiert und müssen vom Nutzer somit nur nach an der y-Achse rotiert werden. Falls die 3D-Modelle auch aus anderen Quellen kommen sollen, dann bräuchte der Nutzer auch die Möglichkeit diese um die z-Achse zu rotieren, da dann nicht mehr garantiert werden kann, dass die Rotation übereinstimmt. Da sich die Roboterdaten und 3D-Modelle denselben Maßstab teilen braucht der Nutzer nicht die Möglichkeit diese zu skalieren. Durch den Einsatz von 3D-Modellen aus anderen Quellen, wäre diese Möglichkeit aber möglicherweise nötig.
% TODO Schaubild in dem Datenbankstruktur um die entsprechende Tabelle erweitert wird (3D-Modelle und Positionen)

\subsection{Deployment}

Die Webanwendung wird mithilfe der actions-gh-pages GitHub Action auf GitHub Pages veröffentlicht.
% TODO Genauer erläutern
Die Anwendung verwendet verschiedene Funktionen der chayns-api, wie beispielsweise das Anfordern eines Zugangstokens, ohne den bestimmte Funktionen des Backends nicht aufgerufen werden können. Aus diesem Grund funktioniert die Anwendung nur, wenn sie auf einer chayns Seite eingebunden ist. Der Zugriff auf die meisten Funktionen des Backends ist so eingeschränkt, dass diese nicht von beliebigen chayns Seiten aufgerufen werden können. Nur bestimmte GET-Endpunkte des Backends sind öffentlich zugänglich, sodass nur die Übersicht über die Roboter öffentlich zugänglich ist.

\subsection{Evaluierung des Prototyps}

\subsubsection{funktionale Anforderungen}
Da die meisten funktionalen Anforderungen erfüllt werden konnten, werden nur die Anforderungen erwähnt die nicht erfüllt werden konnten. Bei dem Protyp handelt es sich zwar - wie in den Anforderungen definiert - um eine responsive Webanwendung, sie funktioniert allerdings nicht auf allen Geräten vollständig. So können die für die Gebäudemodelle genutzten \ac{glTF}-Modelle nicht im Safari Browser angezeigt werden. Da es sich hierbei um eine Beschränkung des Safari-Browsers und nicht der Anwendung selbst handelt, die in Zukunft von Apple behoben werden könnte und weil alle anderen Funktionen des Prototyps auch im Safari-Browser funktionieren, wurde kein Workaround entwickelt. Während die Positionsänderungen der Roboter animiert werden, ist das bei den Rotationsänderungen aufgrund eines Bugs in \deckgl{} nicht der Fall. Aus diesem Grund ist die Anforderung, dass der Roboter in der Übersicht fährt nur teilweise erfüllt. Alle anderen funktionalen Anforderungen wie die an die Nutzerrechte und Verwaltungsansicht konnten erfüllt werden.

Die Anforderungen an die Methode zur Gebäudemodell-Generierung konnten weitestgehend erfüllt werden. Für die Methode wird zwar ein teures iPhone benötigt, dieses besitzt man aber bereits unter umständen. Das Generieren der Modelle erfordert vergleichsweise wenig Aufwand, wobei dieser auch variabel sein kann, je nachdem wie genau man das Scannen durchführen will. Für das Scannen ist nur wenig Know-How nötig. Für das Komprimieren wird zwar ein eigenes Webtool nötig, diese könnte aber mithilfe des gltf-transform Pakets beim import in den Prototyp automatisiert werden.
% gltf-transform Quelle
Die Qualität der erzeugten Modelle variiert zum einen dadurch wie gut der Scann durchgeführt wurde und welche Methode zur Komprimierung des Modells genutzt wird. Vergleichsweise geringe Ungenaugkeiten im Modell haben keinen Einfluss auf die Übersichtlichkeit und damit die Hauptfunktion des Modells. 

\subsubsection{Benutzerfreundlichkeit}
% TODO Analyse der nicht-funktionalen Anforderungen

\paragraph{Usability Heuristics}
In der folgenden Abbildung werden die Usability Heuristics zusammengefasst. Im Folgenden werden diese basierend auf der Quelle erklärt.
% Quelle Nielsen
Bei der ersten Regel geht es darum, dass der Nutzer immer innerhalb einer angemssenen Zeispanne durch geeignete Rückmeldungen mitbekommt, was gerade passiert. Diese Regel ist durch verschiedene Features in der Übersicht und Steuerung erfüllt. Zum einen gibt es die schnellen Aktualisierungen des Roboterstandorts und -status über die \gls{Websocket}-Verbindung mit dem \ac{BCB}. Zum anderen werden Statusänderungen auch über die Farben der Buttons signalisiert. Auch gibt es Wait Cursor um Ladevorgänge anzuzeigen. In der Verwaltung werden Einstellungsänderungen direkt angezeigt.

Die zweite Regel erwartet, dass der Nutzer die Sprache der Anwendung versteht und somit beispielsweise möglichst wenig Fachsprache verwendet wird. In der Steuerung und Verwaltung gibt es nur wenig Text, da vor allem Icons eigesetzt werden. In der Verwaltungsansicht werden möglicherweise unklare Begriffe wie Ladestation über Tooltips erklärt. Außerdem werden Einstellungsänderungen über Dialoge erklärt.

Da Benutzer oft versehentlich Aktionen ausführen, gibt es die dritte Regel, mit der klar gekennzeichnete Abbruchoptionen gefordert werden, um unerwünschte Aktionen abbrechen oder rückgängig machen zu können. Um die Kamera wieder in die Ausgangsposition zu bringen, wenn diese versehentlich an eine ungewünschte Position bewegt wurde, gibt es in der Übersicht einen entsprechenden Button. In der Steuerung gibt es einen Button mit dem der aktuelle Lieferauftrag des Roboters abgebrochen werden kann. Auch gibt es sowohl in der Steuerung als auch in der Verwaltung Bestätigungsdialoge mit denen neue Aktionen und Einstellungsänderungen bestätigt werden müssen. Beim versehentlichen Anklicken eines Buttons, kann die folgende Aktion somit verhindert werden. Im Editiermodus gibt es die Möglichkeit das Verschieben und Rotieren von Objekten rückgängig zu machen oder zu wiederholen. Auch gibt es im Editiermodus einen Button mit dem das editieren ohne Speichern abgebrochen werden kann.

Die vierte Regel sagt aus, dass die UI den Konventionen der Plattform folgen soll und die UI innerhalb der gesamten Anwendung einheitlich ist, damit die Funktion aller Elemente leicht verständlich ist. Diese Regel wird durch den Einsatz der chayns-components für alle GUI Elemente garantiert. So ist die Anwendung sowohl innerlich, als auch unter chayns-Anwendungen einheitlich. 
% ggf. Schaubild in dem Einheitlichkeit zwischen Nutzerkarte und Editiermodus gezeigt wird.
Die Navigation innerhalb der Karte ist nicht einheitlich mit anderen Kartenanwendungen im Web. So lässt sich die Karte in der Google Maps App mit zwei Fingern vertikal rotieren. Im Prototyp werden stattdessen drei Finger gebraucht. Dieser Umstand ist dem eingesetzten Framework \deckgl{} geschuldet.
% deckgl controller doku

In der fünften Regel geht es darum, dass Probleme die Fehler auslösen verhindert werden sollten. In der Steuerung ist es zum Beispiel nicht möglich ungültige Standorte in der Routenplanung einzugeben. In der Verwaltung wird diese Regel durch die bereits erwähnten Bestätigungsdialoge erfüllt. Im Editiermodus gibt es die bereits erwähnte rückgängig und wiederholen Funktion.

Mit der sechsten Regel wird gefordert, dass sich der Nutzer Informationen zwischen verschiedenen Teilen der Benutzeroberfläche nicht merken muss. Die Anwendung ist so aufgeteilt, dass jeder Nutzer basierend auf seinen Berechtigungen Zugriff auf alle nötigen Informationen hat. In allen Ansichten sind die nötigen Informationen sichtbar, sodass sich Nutzer diese nicht zwischen verschiedenen Ansichten merken müssen.

In der siebten Regel geht es um die Möglichkeit bestimmte, häufig genutzte Aktionen, schneller auszuführen. Diese Regel wird in der Steuerung durch die Möglichkeit ermöglicht, den Lieferstandort und Roboter sowohl über die Karte als auch über einen Input und eine Dropdownliste auswählen zu können. Im Editiermodus gibt es die Shortcuts zum rückgängig machen und wiederhohlen.

Die achte Regel, die eine minimalistische Benutzeroberfläche erwartet, ist nur subjektiv bewertbar. Mithilfe der Usability Tests kann gut bewertet werden, welche Informationen und Elemente irrelevant sind oder selten gebraucht werden und dadurch überflüssig sind.

Laut der neunten Regel sollten Fehlermeldungen in einfacher Sparche formuliert sei, das Problem präzise beschreiben und konstruktiv eine Lösung vorschlagen. Hierfür gibt es verschiedene Dialoge die bei Fehlermeldungen angezeigt werden.

Die zehnte Regel sagt aus, dass es, wenn nötig eine Dokumentation geben sollte, mithilfe welcher die Benutzer ihre Aufgaben verstehen und Abschließen können. Die Anwendung wurde mit dem Ziel entwickelt selbsterklärend zu sein. 
% Dieses Ziel noch irgendwo zu Beginn erwähnen
Außerdem gibt es Tooltips für bestimmte Statusinformationen und beim Ändern von Einstellungen gibt es Bestätigungsdialoge mit Erklärungen. Mithilfe der Usability Tests kann geprüft werden, ob das Ziel erfüllt werden konnte oder ob weitere Erklärungen nötig sind.

\paragraph{Usability Tests}
Laut der Analyse wurden die 10 Usability Heuristics weitestgehend erfüllt, womit der Prototyp folglich Benutzerfreundlich ist. Diese Annahme wird mithilfe der folgenden Usability Tests geprüft.

% Fragenkatalog Beispiele
% nur Testpersonen die bereits mit chayns vertraut sind, damit nicht gleichzeitig auch die Usability von chayns getestet wird
% nur Testpersonen die den Prototyp noch nicht gesehen haben

% Ergebnisse zusammenfassen

\subsubsection{Performance}
% => Performance Tests (testen welche Maßnahmen welche Performance Auswirkungen haben)
% Maßnahmen
% Nutzung des .glb Formats statt .obj (beides mit und ohne Kompression)
    % Einfluss auf Ladezeiten (Netzwerk und Rendering)
    % Einfluss auf GPU und CPU Auslastung
% Caching der Robotermodelle
% Caching aller anderen Anfragen (Bis auf Roboter)
% Sehr Kurzzeitiges Caching der Roboter
% Initialisierung der Karten Vorschau über Button statt beim Öffnen des Aufklappers (vielleicht nicht ganz passend?)
