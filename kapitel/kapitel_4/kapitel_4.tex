\newpage
\section{Implementierung}
Im Folgenden wird die Implementierung, sowie die Evaluierung des Prototyps beschrieben.

Fehlender-Text

\subsection{Implementierung des Prototyps}
% ggf. wird ein weiteres Prototyp-Backend erstellt in dem die Daten abgespeichert werden, die aktuell hard-coded sind. Falls dieses Backend erstellt wird, sollte das hier noch erwähnt werden
Der Prototyp besteht aus dem Frontend, dass auf das \ac{BCB} zugreift, um die Roboterdaten anzufragen. Wie dieses mit den Robotern kommuniziert, wurde in einem vorherigen Kapitel erklärt. % Referenz auf dieses Kapitel?
Bei dem Frontend handelt es sich um eine Webanwendung, die auf AWS gehostet ist und auf chayns-Seiten eingebunden werden kann. Für die Entwicklung wurde das Web-Framework React JS genutzt, welches auf HTML, CSS und Javascript basiert. Statt Javascript wurde Typescript eingesetzt, da es durch statische Typisierung eine frühzeitige Fehlererkennung und eine bessere Wartbarkeit des Codes bietet. Für eine bessere Übersichtlichkeit sind die Stylesheets in SCSS statt in CSS geschrieben. Die Zustandsinformationen der Anwendung werden zentral mithilfe von React Redux gespeichert. Die Grundstruktur des Frontend-Projekts wurde mihilfe des Shell Befehls "npx create-chayns-app" generiert. Mithilfe des npm-Pakets "chayns-toolkit" wurde die Kompilierung des Codes konfiguriert. Die eingesetzten GUI-Elemente wie Buttons und Aufklapper werden durch die Komponentenbibliothek "chayns-components" bereitgestellt. Die Typescript-Typen der Objekte, die aus dem \ac{BCB} empfangen werden, konnten aus einem anderen Frontend-Projekt kopiert werden.

\subsubsection{Verwaltungsansicht}
In der Verwaltungsansicht gibt es eine Übersicht über die existierenden Roboter und Stockwerke. So gibt es zum einen eine Liste der existierenden Roboter, über die man Zugriff auf verschiedene Informationen hat. So sind hier unter anderem auch Informationen ersichtlich, auf die man wegen fehlender Berechtigungen in den anderen Anischten keinen Zugriff hat. Hierbei handelt es sich um Informationen wie die Systeminterne \ac{ID} und die Neustart-Zeit des Roboters. Über diese Liste lassen sich zusätzlich auch Einstellungen der Roboter ändern. So hat der Administrator hier beispielsweise die Möglichkeite den Namen, den Ausgabepunkt oder die Homebase des Roboters zu ändern. Auch gibt es in dieser Ansicht eine mit \deckgl{} implementierte Vorschau der Karte, in der die Position des Roboters, sowie die Positionen der Roboterdaten ersichtlich sind. Da sich die Roboter in dieser Ansicht nicht steuern lassen, gibt es außerdem einen Button, über den zur Ansicht für Kellner navigiert wird.

Bis auf die Vorschau der Karte ist die Verwaltungsansicht nicht besonders komplex. Da die Daten der Roboter und Stockwerke sauber strukturiert sind, lassen sich die Informationen mithilfe von React einfach mappen. Für die Vorschau der Karte wird die Kellneransicht wiederverwendet. Ein paar Features wie das Steuern der Roboter ist hierbei einfach deaktiviert.

\paragraph{Import der 3D-Modelle}

\paragraph{Synchronisierung des Gebäudemodells und der Roboterdaten}
Im vorherigen Kapitel wurde erläutert, warum die Synchronisierung der Roboterdaten mit den 3D-Modellen manuell durchgeführt werden muss. Es wurde ein Editor implementiert und im Prototyp eingebunden, mit dem der Nutzer die 3D-Modelle in Relation zu den Roboterdaten positionieren und rotieren kann.

Der Editor nutzt, so wie andere Teile der Anwendung \deckgl{} um 3D-Modelle und Roboterdaten dazustellen. In \deckgl{} bildet die x-Koordinate die Ost-West-Achse, die y-Koordinate die Nord-Süd-Achse und die z-Koordinate die Höhe ab. Mithilfe der in \deckgl{} integrierten Events onDragStart, onDrag und onDragEnd kann das angeklickte Objekt per Ziehen der Maus verschoben und rotiert werden. Beim Drücken der Steuerungstaste wird das angeklickte Modell verschoben und beim Drücken der Shift-Taste rotiert. Beim Drücken der Steuerungs- oder Shift-Taste werden die Objekte durchsichtigt um zu kommunizieren, dass diese nach dem anklicken bewegt werden können. Das Verschieben und Rotieren kann mithilfe der Tastenkombination Strg + Z rückgängig gemacht und mit Strg + Y wiederholt werden. Hierfür existieren zwei Stapel in denen vergangene Aktionen gespeichert werden.
% Initiale Ansicht Position kann eingestellt werden

Die 3D-Modelle können an der x- und y-Achse verschoben und an der y-Achse rotiert werde. Warum keine anderen Transformationen nötig sind, wird im folgenden Abschnitt erläutert.

\paragraph{Unnötige Transformationen}

Der Boden der 3D-Modelle liegt relativ konstant auf der z-Koordinate 0. Aufgrund der Ungenauigkeiten die durch den \ac{LiDAR}-Scan entstehen ist der Boden aber nicht vollständig eben. Da die Roboterdaten zweidimensional und somit keinen Höhenwert haben besteht die Gefahr, dass diese an manchen Stellen unter den 3D-Modellen verschwinden, wenn auf der z-Koordinate 0 positioniert werden. Aus diesem Grund werden die Roboterdaten stattdessen an der z-Koordinate 0,1 positioniert. Da der Boden bei allen 3D-Modellen an derselben z-Koordinate positioniert ist, müssen diese durch den Nutzer nicht weiter an der z-Achse verschoben werden.

Im Vergleich zu den Roboterdaten sind die 3D-Modelle immer um 90° an der z-Achse und einen beliebigen Wert an der y-Achse rotiert. Die Rotation an der x-Achse ist bereits synchron. Die 3D-Modelle werden automatisch um -90° an der z-Achse rotiert und müssen vom Nutzer somit nur nach an der y-Achse rotiert werden.

Da sich die Roboterdaten und 3D-Modelle denselben Maßstab teilen müssen diese durch den Nutzer nicht skaliert werden.

\subsubsection{Übersicht}
In der Übersicht werden die Roboterdaten in Kombination mit den Gebäudemodellen mithilfe von \deckgl{}  angezeigt. Hierfür werden verschiedene \deckgl{}-Layers eingesetzt.

\paragraph{Gebäudemodelle}
% TODO Beschreiben von wo die 3D-Modelle geladen werden (chayns.space?)
Die Gebäudemodelle werden aus bereits erläuterten Gründen im \ac{glTF}-Format geladen und in der ScenegraphLayer angezeigt. Die ScenegraphLayer ist dafür ausgelegt, ein bestimmtes 3D-Modell an verschiedenen Positionen anzuzeigen. Aus diesem Grund muss für jedes 3D-Modell eine eigene Instanz der ScenegraphLayer erzeugt werden. 
% TODO Quelle Scenegraph Layer Doku
Hierdurch sind keine negativen Auswirkungen auf die Performance zu erwarten, da \deckgl{} auf die Nutzung vieler Ebenen ausgelegt ist.
% TODO Quelle deckgl zu Layers
Für die ScenegraphLayers ist das Backface Culling aktiviert.
Dadurch werden wird die Rückseite der Polygone, und somit von der Kamera abgewandte Zimmerdecken und Wände durchsichtig, sodass der Nutzer von außen in die Räume hinein sehen kann. 
% TODO Quelle Backface Culling
Außerdem ist für die ScenegraphLayers das \ac{PBR} Lighting aktiviert. \ac{PBR} ist bestimmt die Lichtverhältnisse, abhängig des Materials eines 3D-Modells. Hierdurch wird eine bessere Qualität erreicht.
% TODO Erwähnen falls 3D-Modelle gecached werden

\paragraph{Roboterdaten}
Im Gegensatz zu den Gebäuademodellen werden die Robotermodelle im \ac{OBJ}-Format und somit in der SimpleMeshLayer angezeigt. Mit der ScenegraphLayer gibt es verschiedene Probleme, wodurch die SimpleMeshLayer brauchbarer, aber auch nicht ideal, ist. So können die Positionen der Roboter in der ScenegraphLayer nicht animiert werden. Auch gibt es mit der ScenegraphLayer Probleme bei der erneuten Initialisierung einer Layer, wodurch die 3D-Modelle nicht erneut angezeigt werden könnne, nachdem diese ausgeblendet werden. Bei beiden Problemen handelt es sich wahrscheinlich um Bugs in \deckgl{}. Das Animieren der ScenegraphLayer sollte zumindest laut der Dokumentation möglich sein. 
% Quelle ScenegraphLayer
Wie bereits erwähnt, lässt sich die Materialdatei des \ac{OBJ} Formats nicht in der SimpleMeshLayer einbinden, weshalb die Roboter einfarbig angezeigt werden. Das ist nicht unbedingt ein Nachteil, denn so können die Roboter für den Nutzer besser sichtbar sein. Die Positionsänderungen der Roboter werden über die transitions Property animiert. Allerdings lässt sich die Rotation nicht animieren, was vermutlich auch auf einen Bug in \deckgl{} zurückzuführen ist.

Über den Robotermodellen wird mithilfe der IconLayer außerdem der aktuelle Status der Roboter angezeigt. In einer IconLayer Instanz können im Gegensatz zur ScenegraphLayer verschiedene Icons angezeigt werden. 
% Quelle IconLayer Doku
Die Icons stammen aus Fontawesome und werden aus einem \ac{npm}-Paket als \ac{SVG} importiert. Da die IconLayer keine \ac{SVG}-Dateien anzeigen kann, werden die SVG-Dateien in Data-URLs umgewandelt.
% Quelle IconLayer Doku.
% TODO eventuell Quellcode für Umwandlung hinzufügen?
Wurde ein Roboter ausgewählt und hat dieser einen Lieferauftrag, dann wird der Zielstandort farbig markiert.

Für die Roboter gibt es außerdem Buttons, die unabhängig vom ausgewählten Stockwerk ausgewählt werden können. So können Roboter ohne großes Suchen gefunden werden.

Die verschiedenen Standorte - Lieferpunkte, Ausgabepunkte und Ladestationen - werden über die IconLayer angezeigt. Wie bei den Roboter-Zuständen werden hierfür verschiedene Fontawesome-Icons genutzt. Die Pfade und virtuellen Wände werden über die PathLayer angezeigt. Diese können durch unterschiedliche Farben voneinander differenziert werden. 
% TODO Quelle PathLayer Doku
Hier reicht eine PathLayer-Instanz aus, um diese anzuzeigen.
% TODO Falls Virtuelle Wände mit Dashes angezeigt werden => Zwei Ebenen; Falls nicht => Eine Ebene

\paragraph{Echtzeit-Aktualisierung}
% TODO Websocket erwähnen
Die Positionen sowie weitere Statusinformationen der Roboter, wie beispielsweise der aktuelle Auftrag und Akkuladung, werden mithilfe einer \gls{Websocket}-Verbindung zwischen der Webanwendung und dem \ac{BCB} regelmäßig aktualisiert. Diese Informationen werden zentral im Redux-Store aktualisiert, sodass die aktualisierten Informationen direkt dem Nutzer angezeigt werden können. Damit die aktualisierten Informationen in den Ebenen angezeigt werden, wird die updateTriggers Property in diesen gesetzt.

Die Positonsänderungen der Roboter werden mithilfe des transitions Attribute der SimpleMeshLayer animiert. So entsteht der Eindruck, dass die Roboter fahren. Wie bereits erwähnt lässt sich hierbei allerdings nur die Position, aber nicht die Rotation animieren.

\paragraph{Interaktion}
Die Roboter, sowie die Standorte sind, mithilfe der onClick Property der entsprechenden Ebene, auswählbar. So werden ausgewählte Standorte und Roboter verfärbt angezeigt. Außerdem erscheint ein Button über den sich weitere Informationen wie beispielsweise die Akkuladung bei Robotern und der Name bei Standorten anzeigen lässt. Es gibt zudem die Möglichkeit einem Roboter zu Folgen. Die Kamera wird hierfür mithilfe des FlyToInterpolators zu dem Roboter bewegt. Bei Aktualisierung der Roboterposition wird die Kameraposition mithilfe der transitionDuration Property animiert.

Über Buttons kann zwischen den verschiedenen Stockwerken navigiert werden. 

\subsubsection{Steuerung}
Es gibt drei verschiedene Aktionen zum Steuern der Roboter: Lieferauftrag, Laden und Abbrechen. Mit dem Laden und Abbrechen wird der aktuelle Lieferauftrag abgebrochen, worauf der Nutzer auch hingewiesen wird. Für beide Aktionen gibt es jeweils einen Button, der klickbar ist, sobald ein Roboter ausgewählt wurde. Für das Einstellen eines Lieferauftrags muss ein Ziel und ein Roboter ausgewählt werden. Hierfür gibt es zum einen Inputs, mit denen nach beidem gesucht werden kann. Auch lassen sich Ziel und Roboter mit der Auswahl über die Karte festlegen. Die Roboter können zudem über ihre Buttons ausgewählt werden.

\subsubsection{Datenstrukturen}

\subsubsection{Deployment}

Die Webanwendung wird mithilfe der actions-gh-pages GitHub Action auf GitHub Pages veröffentlicht.

\newpage
\subsection{Evaluierung des Prototyps}
Fehlender-Text