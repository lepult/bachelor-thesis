\newpage
\section{Technische Herausforderungen}
Vor und während der Implementierung des Prototyps sind verschiedene größere technische Herausforderungen aufgetreten, die gelöst werden mussten. Die Herausforderungen mit den gewählten Lösungsansätzen werden in diesem Kapitel vorgestellt. 

\subsection{3D Modelle von Gebäuden}
Fehlender-Text

\subsection{3D Visualisierung im Web}
Für die Einbindung von 3D-Visualisierungen im Web gibt es verschiedene Ansätze und Technologien. In diesem Abschnitt wird die Auswahl von \deckgl{} als Framework für die Umsetzung des Prototyps, sowie die Wahl des Dateiformats für die 3D-Modelle erläutert.

\subsubsection{deck.gl}
Für die Umsetzung des Prototyps wurde \deckgl{} statt ein Framework mit allgemeinerer 3D-Programmierung wie three.js gewählt. Grund hierfür ist, dass die Anwendung als Karte genutzt werden soll und \deckgl{} für das Entwickeln von Karten ausgelegt ist. So ist bereits die Navigation und das Verhalten der Kamera passend konfiguriert, sodass sich bei der Entwicklung nur auf die Darstellung der Karte fokusiert werden muss. Mit dem Einsatz von three.js würde deutlich mehr Aufwand für die Implementierung gebraucht, da die Navigation und das Verhalten der Kamera für Karten implementiert werden müsste. Vor der Implementierung wurde geprüft, dass die Anforderungen an die Anwendung mithilfe von \deckgl{} überhaupt erfüllt werden können.

\subsubsection{Dateiformat der 3D-Modelle}\label{sec:ModelFileFormat}
Für die Darstellung eines 3D-Modells gibt es in \deckgl zwei Möglichkeiten: das Einbinden des \ac{OBJ} Dateiformats in der SimpleMeshLayer \cite{DeckglSimpleMeshLayer} und das Einbinden des \ac{glTF} Dateiformats in der ScenegraphLayer \cite{DeckglScenegraphLayer}. Beide Dateiformate werden in der Scaniverse App als Dateiexport angeboten. Das \ac{OBJ} Format besteht aus einer Datei mit der Endung \obj{} in der die dereidimensionalen geometrischen Formen kodiert sind \cite{OBJSpec} und einer Datei mit der Endung \mtl{} in der die optischen Materialeigenschaften und Texturierung kodiert ist \cite{MTLSpec}. Zur Einbindung des \ac{OBJ} Dateiformats wird die \loadersgl{} Programmbibliothek benötigt, die allerdings nur die \obj Datei und nicht die \mtl Datei parsen kann \cite{OBJLoader}. So können die 3D-Modelle in der SimpleMeshLayer nur ohne Textur angezeigt werden. Das \ac{glTF} Format bietet zwei verschiedene Dateiformate, wobei hier nur die Binary Variation relevant ist. Diese hat die Endung \glb{} und besteht nur aus einer Datei, die neben den geometrischen Formen auch die Materialeigenschaften und Texturierung enthält. Das \ac{glTF} Format bietet eine geringere Dateigröße als vergleichbare Dateiformate.\cite[Abschnitt 2]{glTFSpec} Mithilfe der \loadersgl{} Programmbibliothek lassen sich 3D-Modelle des Formats ohne großen Aufwand in der ScenegraphLayer von \deckgl{} einbinden \cite{DeckglScenegraphLayer}. Da ein 3D-Modell mit einer passenden Texturierung eine bessere Übersichtlichkeit bietet und da \ac{glTF} Dateien eine geringe Dateigröße haben, wird die ScenegraphLayer mit 3D-Modellen im \ac{glTF} Format für die Darstellung der Raummodelle genutzt.

Die \ac{glTF} Dateien, die für den Prototyp aus Scaniverse exportiert werden, sind für den Einsatz in der Webanwendung zu groß. So sind die Dateien zwischen 14 und 21 \ac{mB} groß. Dadurch können die 3D-Modelle nicht auf Mobilgeräten angezeigt werden. Außerdem beeinflusst die Dateigröße die Ladezeit beim Herunterladen der Daten vom Webserver und auch beim Rendern der 3D-Modelle negativ. Aus diesem Grund müssen die Dateien komprimiert werden. Hierfür wurden die 3D-Modelle die im Prototyp eingesetzt werden mit dem OptimizeGLB Online Konverter manuell komprimiert. Insbesondere durch den Einsatz des \ac{WebP} Bildformats für Texturen werden die Dateien effektiv komprimiert.\cite{OptimizeGLB} Die komprimierten Dateien sind zwischen 330 und 550 \ac{kB} groß, was einer Kompression von über 95\% entspricht. Die Qualität der komprimierten 3D-Modelle ist erkennbar geringer, reicht für den Zweck des Prototyps aber trotzdem aus, da größere Merkmale weiter gut erkennbar sind und somit die Übersichtlichkeit weiter garantiert wird.

\subsection{Synchronisierung des Gebäudemodells und der Roboterdaten}
Im Prototyp sollen die Roboterdaten in den 3D-Modellen integriert dargestellt werden. Die Roboterdaten und 3D-Modelle haben den gleichen Maßstab, die Positionen und Rotationen der Datensätze stimmen allerdings nicht miteinander überein. Der Grund hierfür ist, dass zur Generierung der Datensätze unterschiedliche Scanning-Methoden eingesetzt werden. Auch die Positionen der 3D-Modelle stimmen nicht miteinander überein, da beim Scannen an verschiedenen Ausganspunkten angefangen wurde.

Aus diesem Grund müssen die Positionen der Roboterdaten mit den 3D-Modellen synchronisiert werden. Auch müssen die Positionen der 3D-Modelle unterienander synchronisiert werden. Eine automatische Synchronisierung ist aus verschiedene Gründen zu komplex. Zum einen sind die Formate der Daten zu verschieden, denn während die 3D-Modelle aus komplexen dreidimensonalen Formen bestehen, setzen sich die Roboterdaten aus zweidimensonalen Linien und Punkten zusammen. Zum anderen gibt es in beiden Datensätzen unterschiedliche Ungenaugkeiten in Bezug auf die Realität. Sowohl \ac{VSLAM}, mit dem die Roboterdaten untereinander positioniert werden als auch das \ac{LiDAR}-Scanning, mit dem die 3D-Modelle für den Prototyp generiert wurden, sind fehlerbehaftet. Da sich diese Scanning-Methoden unterscheiden und somit verschiedene Stärken und Schwächen beim Scannen haben, sind die Ungenauigkeiten zwischen den Roboterdaten und 3D-Modellen größer, während die Ungenauigkeiten zwischen den verschiedenen 3D-Modellen geringer sind.

Da eine automatische Synchronisierung der Datensätze ausgeschlossen ist, muss diese manuell vorgenommen werden. Hierfür wurde ein Editiermodus im Prototyp implementiert, mit dem der Administrator die 3D-Modelle und Roboterdaten durch Verschieben und Rotieren der 3D-Modelle synchronisieren kann. Die Implementierung wird im Kapitel \ref{sec:EditMode} genauer beschrieben.
