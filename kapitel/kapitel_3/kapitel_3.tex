\newpage
\section{Technische Herausforderungen}
Vor und während der Implementierung des Prototyps sind verschiedene größere technische Herausforderungen aufgetreten, die gelöst werden mussten. Die Herausforderungen werden in diesem Kapitel mit den gewählten Lösungsansätzen vorgestellt. 

\subsection{3D Modelle von Gebäuden}
TODO: Erklären warum LiDAR Scanning genutzt wird; Erklären warum die Scaniverse App genutzt wird.

\subsection{3D Visualisierung im Web}
Für das Einbinden von 3D-Visualisierungen im Web gibt es verschiedene Ansätze und Technologien. In diesem Abschnitt wird die Auswahl von \deckgl{} als Framework für die Umsetzung des Prototyps, sowie die Wahl des Dateiformats für die 3D-Modelle erläutert.

\subsubsection{deck.gl}
Für die Umsetzung des Prototyps wurde \deckgl{} gewählt. Das Framework wurde gewählt, da die Anwendung als Karte genutzt werden soll und \deckgl{} für das Entwickeln von diesen ausgelegt ist. So ist die Navigation und das Verhalten der Kamera bereits passend konfiguriert, sodass bei der Entwicklung dieser Aspekte Zeit gespart werden kann wodurch ein größerer Fokus auf die Darstellung Karte gelegt werden kann. Vor der Implementierung konnte bestätigt werden, dass die Anforderungen an die Anwendung mit dem Framework erfüllt werden können.

\subsubsection{Dateiformat der 3D-Modelle}\label{sec:ModelFileFormat}
Für die Darstellung eines 3D-Modells gibt es in \deckgl{} zwei Möglichkeiten: das Einbinden des \ac{OBJ} Dateiformats in der SimpleMeshLayer \cite{DeckglSimpleMeshLayer} und das Einbinden des \ac{glTF} Dateiformats in der ScenegraphLayer \cite{DeckglScenegraphLayer}. Beide Dateiformate werden in der Scaniverse App als Dateiexport angeboten.

Das \ac{OBJ} Format besteht aus einer Datei mit der Endung \obj{}, in der die dereidimensionalen geometrischen Formen kodiert sind \cite{OBJSpec} und einer Datei mit der Endung \mtl{}, in der die optischen Materialeigenschaften und Texturierung kodiert sind \cite{MTLSpec}. Für die Einbindung des \ac{OBJ} Dateiformats wird die \loadersgl{} Programmbibliothek benötigt, die allerdings nur die \obj Datei und nicht die \mtl{} Datei parsen kann \cite{OBJLoader}. So können die 3D-Modelle in der SimpleMeshLayer nur ohne Textur angezeigt werden.

Das \ac{glTF} Format bietet zwei verschiedene Dateiformate, wobei hier nur die Binary Variation relevant ist. Diese hat die Endung \glb{} und besteht nur aus einer Datei, die neben den geometrischen Formen auch die Materialeigenschaften und Texturierung enthält. Das \ac{glTF} Format bietet eine geringere Dateigröße als vergleichbare Dateiformate.\cite[Abschnitt 2]{glTFSpec} Mithilfe der \loadersgl{} Programmbibliothek lassen sich 3D-Modelle des Formats ohne großen Aufwand in der ScenegraphLayer von \deckgl{} einbinden \cite{DeckglScenegraphLayer}. Da ein 3D-Modell mit einer passenden Texturierung eine bessere Übersichtlichkeit bietet und \ac{glTF} Dateien eine geringe Dateigröße haben, wird die ScenegraphLayer mit 3D-Modellen im \ac{glTF} Format für die Darstellung der Raummodelle genutzt.

Die \ac{glTF} Dateien, die für den Prototyp aus Scaniverse exportiert werden, sind mit iner Dateigröße von 14 bis 21 \ac{mB} für den Einsatz im Prototyp zu groß. 3D-Modelle mit dieser Größe können nicht auf Mobilgeräten angezeigt werden. Außerdem beeinflusst die Dateigröße die Ladezeiten negativ - sowohl beim Herunterladen der Daten vom Webserver als auch beim Anzeigen der 3D-Modelle. Aus diesem Grund müssen die Dateien komprimiert werden. Hierfür sind die 3D-Modelle die im Prototyp eingesetzt werden mit dem OptimizeGLB Online Konverter manuell komprimiert. Insbesondere durch den Einsatz des \ac{WebP} Bildformats für Texturen werden die Dateien effektiv komprimiert.\cite{OptimizeGLB} Die komprimierten Dateien sind zwischen 330 und 550 \ac{kB} groß, was einer Kompression von über 95\% entspricht. Die Qualität der komprimierten 3D-Modelle ist erkennbar geringer, reicht aber für den Zweck der Anwendung trotzdem aus, da größere Merkmale weiter gut erkennbar sind und somit die Übersichtlichkeit weiter garantiert wird.

\subsection{Synchronisierung des Gebäudemodells und der Roboterdaten}
Im Prototyp sollen die Roboterdaten in den 3D-Modellen integriert dargestellt werden. Die Roboterdaten und 3D-Modelle haben den gleichen Maßstab, die Positionen und Rotationen der Datensätze stimmen allerdings nicht miteinander überein. Diese Unterschiede sind eine Konsequenz daraus, dass zur Generierung der Datensätze unterschiedliche Scanning-Methoden eingesetzt werden. Außerdem stimmen die Positionen der 3D-Modelle nicht unterienander überein, da beim Scannen an verschiedenen Ausganspunkten angefangen wird.

Aus diesem Grund müssen die Positionen der Roboterdaten mit den 3D-Modellen synchronisiert werden. Auch müssen die Positionen der 3D-Modelle unterienander synchronisiert werden. Eine automatische Synchronisierung ist aus verschiedene Gründen zu komplex. Zum einen sind die Formate der Daten zu verschieden, denn während die 3D-Modelle aus komplexen dreidimensonalen Formen bestehen, setzen sich die Roboterdaten aus zweidimensonalen Linien und Punkten zusammen. Zum anderen gibt es in beiden Datensätzen unterschiedliche Ungenaugkeiten in Bezug auf die Realität. Sowohl \ac{VSLAM}, mit dem die Roboterdaten untereinander positioniert werden als auch das \ac{LiDAR}-Scanning, mit dem die 3D-Modelle generiert werden, sind fehlerbehaftet. Da sich diese Scanning-Methoden unterscheiden sich diese Ungenaugkeiten.

Da eine automatische Synchronisierung der Datensätze ausgeschlossen ist, muss diese manuell durch den Nutzer vorgenommen werden. Desihalb wurde ein Editiermodus implementiert, mit dem der Administrator die 3D-Modelle und Roboterdaten durch Verschieben und Rotieren der 3D-Modelle synchronisieren kann. Die Implementierung wird im Abschnitt \ref{sec:EditMode} genauer beschrieben.
