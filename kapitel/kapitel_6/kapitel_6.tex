\newpage
\section{Diskussion}
Im Rahmen dieser Arbeit sollte die beantwortet werden, wie eine effiziente und benutzerfreundliche Steuerung und Verwaltung von Servicerobotern implementiert werden kann. Es wurde ein Prototyp entwickelt der diese Anforderungen erfüllt und es wurde vorgestellt wie dieser im Detail entwickelt wurde. Außerdem sollte zusätzlich eine Methode zur einfachen Generierung von 3D-Modellen identifiziert und genutzt werden. Es wurde eine passende Methode gefunden, die erfolgreich eingesetzt wurde. Im Folgenden werden die Ergebnisse dieser Arbeit genauer zusammengefasst und interpretiert.

\subsection{Erfüllung der Anforderungen}
Wie in Kapitel \ref{sec:EvaluationFunctionalRequirements} beschrieben konnten die funktionalen Anforderungen erfüllt werden, wodurch auch der entsprechende Teil der Forschungsfrage, nämlich die Implementierung einer Steuerung und Verwaltung von Servicerobotern, erfüllt wurde. Wie im Kapitel \ref{sec:BackgroundAndMotivation} erwähnt, sollen die Roboter zunächst für kürzere Botengänge eingesetzt werden, wobei der Einsatz in Gastronomiebetrieben im Raum steht. Die Anforderungen wurden für die Durchführung von Botengängen definiert. Für den Einsatz in der Gastronomie müsste der Prototyp um weitere Funktionen wie eine erweiterte Routenplanung ergänzt werden.

Das Einhalten der Usability Entscheidungsregeln nach Nielsen \cite{Nielsen.1994} hat maßgeblich dazu beigetragen, dass der Prototyp benutzerfreundlich ist. Hierbei sollte auch beachtet werden, dass der Einsatz von \deckgl{} eine maßgebliche Rolle in der Einhaltung der Entscheidungsregeln spielt, da das Framework zum Beispiel die Navigation innerhalb der Karte mitliefert. Diese orientiert sich bei der Handhabung an anderen gängigen Kartenanwendungen wie Google Maps. Das Framework trägt so beispielsweise dazu bei, dass die vierte Regel der Usability Entscheidungsregeln eingehalten wird, nach welcher den Standards ähnlicher Anwendungen gefolgt werden soll. Wie die Usability Tests gezeigt haben, reicht eine subjektive Einhaltung der Entscheidungsregeln nicht aus, um eine gute Benutzerfreundlichkeit zu garantieren. So sind im Pilottest und in der ersten Usability Test Runde eine Vielzahl an Problemen aufgetreten, obwohl die Entscheidungsregeln weitestgehend eingehalten wurden. Durch die Ergebnisse der Tests und das zusätzlich gesammelte Feedback konnten Änderungen vorgenommen werden, durch die die Benutzerfreundlichkeit verbessert wurde. Basierend auf den Ergebnissen der zweiten Usability Test Runde wird davon ausgegangen, dass die Anforderungen an die Benutzerfreundlichkeit eingehalten werden. Diese Annahme ist zwar schlüssig, aber rückblickend nicht unbedingt ausreichend belegt. So hätten sich hier noch weitere Usability Test Runden angeboten, um zu Prüfen ob noch weitere Probleme auftreten. Weitere Tests hätten auch mit anderen Aktivitäten durchgeführt werden können, da es möglich ist, dass die wenigen nicht getesteten Funktionen weitere gravierende Probleme aufweisen. Gleichzeitig muss aber auch immer der Aufwand mit den potenziellen Erkentnissen abgewogen werden. In dieser Hinsicht ist die Entscheidung, keine weiteren Tests durchzuführen nachvollziehbar.

Die Anforderungen an die Effizienz konnte vor allem durch die Reduktion der Ladezeiten eingehalten werden. So wurden die Ladezeiten durch die Komprimierung der 3D-Modelle zweifach reduziert: Zum einen werden die Modelle durch die kleinere Dateigröße schneller heruntergeladen und zum anderen werden die Modelle durch eine geringere Komplexität schneller gerendert. Die Effizienz wurde anhand der Messwerte \ac{FCP}, \ac{FID} und \ac{TBT}, sowie durch die subjektiv beobachtete Smoothness bewertet. Es muss beachtet werden, dass die Bewertung der Ladezeit durch den \ac{FCP} nicht ausreicht, der viel wichtigere \ac{LCP} allerdings durch Beschränkungen in \deckgl nicht gemessen werden kann. Hierdurch sind die Messwerte leider nicht besonders aussagekräftig. Die subjektiv beobachtete Smoothness dient hier als Ausgleich, damit die Bewertung der Effizienz fundierter ist. Die gemessenen Werte sind nicht optimal, aber trotzdem zumindest meistens ausreichend. Vergleichsweise schlechte Messwerte sind durch die 3D-Darstellung der Stockwerke zu erwarten und somit noch im akzeptablen Bereich. Bei der Prüfung der Smoothness sind keine Ruckler aufgefallen, was ein positives Signal ist. Da die Darstellung der 3D-Modelle einen hohen Rechenaufwand fordert, erscheinen die vergleichsweise schlechten Messwerte in Kombination mit der guten Smoothness ausreichend, wenn auch verbesserungsfähig. Für eine bessere Prüfung der Effizienz müsste \deckgl um ein Event erweitert werden, das ausgelöst wird, wenn eine Ebene erstmals angezeigt wird.

Es wurde vorweg erwartet, dass die Anforderungen an den Prototyp mithilfe von \deckgl{} erfüllt werden können, da das Framework sowie die Möglichkeiten bereits bekannt waren. Trotzdem war vorweg nicht klar, wie bestimmte Funktionen - wie zum Beispiel das Synchronisieren der Roboterdaten und Gebäudemodelle - umgesetzt werden könnten. So war das Verschieben und Rotieren im Editiermodus als Plan B eingeplant, auf den letztendlich auch zurückgegriffen werden musste. Verschiedene Eigenarten von \deckgl{}, wie dass jedes Raummodell über eine eigene ScenegraphLayer-Instanz dargestellt werden muss, waren zum Teil irritierend, aber gleichzeitig meist auch nachvollziehbar. So muss immer beachtet werden, dass das Framework grundsätzlich für die Visualisierung riesiger Geodatensätze und nicht direkt für die Zwecke des Prototyps ausgelegt ist.

Neben der Entwicklung des Prototyps sollte außerdem eine Methode identifiziert und eingesetzt werden, die sich für das einfache Generieren von 3D-Modellen eignet. Es wurden verschiedene Methoden oberflächlich miteinander verglichen, wobei das \ac{LiDAR}-Scannen per iPhone mit der Scaniverse App letztendlich ausgewählt wurde. Trotz verschiedener Schwächen, wie das schlechte Scannen transparenter oder reflektierender Flächen, eignet sich die gewählte Methode gut. So ist sie mit vergleichsweise wenig Aufwand beim Scannen verbunden, erfordert kein gesondertes Know-How und ist mit keinen Anschaffungskosten verbunden, falls ein \ac{LiDAR} fähiges iPhone zur Verfügung steht. In dieser Arbeit wurde explizit nicht nach der am besten geeignetsten Funktion, sondern nur nach einer gut geeigneten Funktion gesucht, um den Umfang der Arbeit nicht zu überziehen. Die Frage, welche Methode am besten geeignet ist, könnte über einen tieferen Vergleich der vorgestellten Methoden beantwortet werden.

\subsection{Einsatz der Technologien}
Der Prototyp wurde basierend auf dem Framework \deckgl{} implementiert, dass eigentlich für die Visualisierung riesiger Geodatensätze ausgelegt ist. Diese Arbeit zeigt, dass ebenenbasierte Visualisieren von Daten nach dem \ac{PIL}-Prinzip, nicht nur für Geodaten, sondern auch für Raumbezogene Daten - wie die Roboterdaten und die 3D-Modelle - geeignet sind. Der umfangreiche Katalog an vordefinierten Ebenen bietet eine ausreichend vielseitige Auswahl an Visualisierungsmöglichkeiten, um die visuellen Anforderungen komplexer Anwendungen zu erfüllen. So konnte die Visualisierung der Daten im Prototyp mithilfe der SimpleMeshLayer, ScenegraphLayer, IconLayer und PathLayer umgesetzt werden. Auch bieten die Ebenen, Controller und View Klassen ausreichend viele Schnittstellen um komplexe Interaktionsmöglichkeiten umzusetzen. So ließ sich das Verschieben und Rotieren der Modelle im Editiermodus über verschiedene Events der Layer Klasse implementieren und das Zurücksetzen der Kameraposition konnte über die View Klasse umgesetzt werden.

Da der Prototyp zum Großteil auf \deckgl{} basiert, gab es vor und während der Entwicklung die Hoffnung, dass die Entwicklung mit dem Framework möglichst unkompliziert ist. Diese Hoffnung wurde größtenteils erfüllt. So ist das \ac{PIL}-Prinzip im Framework intuitiv und gut umgesetzt, was auch die Entwicklung erleichtert. Außerden ist die Dokumentation des Frameworks, bis auf wenige Stellen ausführlich und hilfreich. Zusätzlich gibt es eine aktive Community an Maintainern des Frameworks und Entwicklern, die es nutzen, wodurch die Lösungsfindung bei Problemen vereinfacht wird. Da das Framework regelmäßig Updates bekommt und ab der kommenden Version 9.0.0 auf WebGPU basiert, ist es zukunftssicher.

Der Einsatz der Technologien \ac{Sass}, Typescript, React und React-Redux hat sich als angemessen erwiesen. So konnten mit \ac{Sass} übersichtliche und wiederverwendbare Styles definiert werden. Der Einsatz von Typescript war im nachhinein betrachtet sogar unerlässlich, da die vom \ac{BCB} empfangenen Objekte ohne definierte Typen für eine effiziente Entwicklung zu komplex sind. Da \deckgl{} besonders für den Einsatz mit React geeignet ist, konnten hier Synergien genutzt werden, die sich wahrscheinlich auch auf die Effizienz des Prototyps auswirken. Der Einsatz von React-Redux hat die Entwicklung mit der Vielzahl an angefragten Roboterdaten vereinfacht, da diese zentral gespeichert und aus allen React-Komponenten abgerufen werden können.

\subsection{Bewertung der Methodik}
Zur Beantwortung der Forschungsfrage wurde nach dem \ac{DSR} Ansatz nach Hevner \cite{Hevner2004} gearbeitet. Rückblickend wurde die gewählte Vorgehensweise passend gewählt, da die Hauptaspekte des Forschungsansatzes - die Relevanz-, Strenge- und Design-Schleife - gut abgebildet werden konnten. So wurde ein fertiges Artefakt - der Prototyp - entwickelt. Die Relevanz-Schleife wurde dadurch abgebildet, dass die Anforderungen basierend auf der Umgebung definiert wurden und der Prototyp, im Rahmen der Usability und Performance Tests, innerhalb der Umgebung getestet wurde. Die Strenge Schleife wurde dadurch abgebildet, dass das zur Entwicklung und Auswertung des Prototyps relevante Wissen aus der Wissensbasis entnommen wurde und diese durch die Entwicklung und Auswertung des Prototyps auch erweitert wurde. Zuletzt wurde die Design-Schleife durch die iterative Entwicklung und Auswertung des Prototyps nach dem Verfahren des Rapid Prototypings abgebildet.
